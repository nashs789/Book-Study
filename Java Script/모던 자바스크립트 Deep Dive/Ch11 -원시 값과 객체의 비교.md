# **Chapter11 - 원시 값과 객체의 비교**

# **[ 📋 목차 ]**
- 원시 값
  - 변경 불가능한 값
  - 문자열과 불변성
  - 값의 의한 할당
- 객체
  - 변경 가능한 값
  - 참조에 의한 전달

****

# **[ 🗂️ 정리 ]**
## 📌 <b>원시 값과 객체의 비교</b>

원시 타입과 객체 타입의 차이점

- 원시: Immutable / 객체: Mutable
- 원시: 변수에 할당시 메모리에 값이 저장 / 객체: 변수에는 참조 값이 저장
- 원시: 다른 변수에 할당시 원본의 값이 복사되어 전달(Pass By Value) / 객체: 참조 값이 복사되어 전달(Pass By Reference)

### ⚙ <b>원시 값(Primitive Value)</b>

#### 👉 변경 불가능한 값

원시 타입의 값은 변경 불가능한 값이다. (= Read Only)

> ⭐️ 변경 불가능하다는 것은 변수가 아니라 값에 대한 진술이다. (Chapter04 에서 삽질했던 부분)

상수와 변수의 구분은 필요함, 상수는 변수 값을 변경할 수 없고, 단 한번의 할당만 허용된다.

```javascript
var obj = {};

obj.a = 1;
console.log(obj); // output: {a:1}
```

객체의 경우 위와 같이 변경이 가능하다.

#### 👉 문자열과 불변성
문자는 2바이트, 숫자는 8바이트로 규격이 정해져있고, 문자열은 문자로 이루어진 집합이다.   
문자도 불변 타입으로 변경이 아닌 참조하는 메모리를 변경한다.

유사 배열 객체로 iterable 해서, length 로 길이를 확인하고, for 루프를 돌릴 수 있다.

```javascript
var str = 'string';

str[0] = 'S';

console.log(str); // output: 'string'

str = 'world';

console.log(str); // output: 'world'
```

이미 생성된 문자열의 일부 문자를 변경해도 반영되지 않아, 예기치 않은 변경으로 보호되어 데이터 신뢰성을 보장할 수 있다.  
하지만 변수에 할당하면 새로운 메모리를 참조하기 때문에 재할당 된다.

#### 👉 값의 의한 할당

```javascript
var score = 80;
var copy = score;

console.log(score, copy); // output: 80 80
console.log(score === copy); // output: true
```

변수에 할당된 값은 동일하지만 값에 의해서 전달될 때 다른 메모리 공간에 값이 저장되어 서로는 별개의 값이다.  
엔진 제조사에 따라서 메모리 관리 방식이 다르고, 값이 할당될 때 두 변수가 같은 메모리를 참조하다가, 변수에 재할당이 이루어지면 그 때 다른 메모리 공간을 
사용할 수도 있다. (유사 copy on write 랑 비슷하네)

### ⚙ <b>객체</b>
객체의 프로퍼티는 개수가 정해져있지 않고, 동적으로 추가 및 삭제가 가능하다.

#### 👉 변경 가능한 값
객체는 재할당 없이도 객체를 직접 변경이 가능하면서, 프로퍼티를 동적으로 추가 및 삭제 그리고 갱신이 가능하다.  
변수가 갖는 주소 값은 객체를 참조하고 있다라고 보면 된다.
  
여러개의 식별자가 하나의 객체를 공유할 수 있다.

> Shallow Copy vs Deep Copy

객체 같이 메모리를 공유해 하나의 객체를 여러 변수에서 참조하는걸 Shallow Copy 라고 하며, 원시 타입처럼 새로운 메모리에 할당 하는걸 Deep Copy 라고 한다.

#### 👉 참조에 의한 전달
위와 같이 Deep Copy 를 하지 못하는 객체들은 (메모리 관리 효율성을 위해 -> 새로운 객체 생성 비용) 한 쪽만 프로퍼티에 변경이 있어도, 다른 쪽도 영향을 받기
때문에 구조적인 단점이 생긴다.