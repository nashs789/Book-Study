# **Chapter02 - 컴퓨터의 구조와 성능 향상**

# **[ 📋 목차 ]**
- 하드웨어 사양 관련 용어
- CPU 구성
- 레지스터 종류
- 버스의 종류
- 메모리
- 메모리와 CPU 속도 차이 개선

****

# **[ 🗂️ 정리 ]**
### 📌 하드웨어 사양 관련 용어
- 클록: CPU 속도와 관련된 단위로 CPU와 시스템의 다른 부분이 동기화를 돕는다.
  - 클록 생성기: 클록 신호(펄스 = 클록 틱)를 생성한다
  - 디지털 회로 내에서 데이터 처리, 전송, 수신 등을 조율하는데 필요한 시간적 기준 제
    - ex) 메인보드에서 펄스를 보낼 때마다 데이터를 송, 수신 한다.
- 헤르츠(Hz): 1초 동안의 사이클 또는 진동의 횟수
  - 메모리가 데이터에 접근하거나 전송할 수 있는 속도
  - 측정 예시  
    - 1번: 1Hz
    - 1,000번: 1KHz
    - 1억번: 1GHz
 
****

### 📌 CPU 구성
- 산술논리 연산장치(Arithmetic and Logic Unit, ALU): 데이터의 연산 담당(덧셈, AND 연산 등등)
- 제어장치(Control Unit, CU): CPU의 연산과 명령 실행을 조정하는 장치(명령어 해석, 명령어 실행 순서, 데이터 흐름 등등을 제어한다.)
- 레지스터(Register): 데이터를 임시로 보관

****

### 📌 레지스터 종류
- 사용자 가시 레지스터(user-visible register)
  - 데이터 레지스터(Data Register, DR)
    - CPU에 있는 대부분이 DR이기 때문에 '범용 레지스터로'도 불린다.
    - 연산을 위해 필요한 정보를 보관
    - 처리될, 처리된 데이터를 임시로 저장(메모리 읽기, 쓰기 포함)
  - 주소 레지스터(AR)
    - 데이터 또는 명령어가 저장된 메모리 주소가 저장된다.
    - PC, SP, Index, Base 레지스터가 이에 속한다.
- 사용자 불가시 레지스터(user-invisible register)
  - 프로그램 카운터(Program Counter, PC)
    - 다음 실행할 명령어 주소를 기억했다가 제어장치에 알려준다.
    - 명령어 포인터(Instruction Pointer, IP)로도 불린다.
  - 명령어 레지스터(Interuction Register, IR)
    - 현재 실행중인 명령어를 저장한다.
    - 제어장치가 IR 명령어를 해석 후 외부 장치에 적절한 신호를 보낸다.
  - 메모리 주소 레지스터(Memory Address Register, MAR)
    - 메모리에서 데이터를 가져오거나 반대로 메모리로 데이터를 보낼 때 주소를 지정하기 위해 사용한다.
  - 메모리 버퍼 레지스터(Memory Buffer Register, MBR)
    - CPU와 메모리 사이에서 데이터 중간 저장소 역할
    - 임시 저장으로 CPU와 메모리 사이의 속도 차이를 조절
    - 읽기: MAR이 메모리 위치를 지정하면, 메모리는 MBR/MDR로 데이터를 전송
    - 쓰기: CPU가 메모리에 쓰고자 할 때 MBR/MDR에 데이터를 저장하고 MAR을 통해서 쓰기 작업을 할 메모리 위치 지정 후 지정된 메모리로 데이터 전송
  - 프로그램 상태 레지스터(Program Status Register, PSR)
    - 플래그 레지스터(Flag Register): ALU 연산 결과가 양수인지 음수인지 or 자리올림 유무
    - 플래그 레지스터는 상태 레지스터(Status Register) 혹은 컨디션 레지스터(Condition Register) 라고도 불린다
    - 플래그 비트로 표현
      - 제로 플래그(Zero Flag, Z): 연산 결과가 0인 경우
      - 부호 플래그(Sign Flag, S): 연산 결과가 음수인 경우
      - 오버플로우 플래그(Overflow Flag, V or O): 비트 표현 범위 초과
      - 캐리 플래그(Carry Flag, C): 덧, 뺄셈에서 캐리 혹은 보로우가 발생
      - 패리티 플래그(Parity Flag, P): 마지막 연산 결과가 1인 경우(오류 검출 비트)
      - 인터럽트 허용 플래그(Interrupt Enable Flag, I): 외부 인터럽트 허용
- 메모리 관리와 보안
  - 경계 레지스터(Base Register): 작업의 시작 주소
  - 한계 레지스터(Limit Register): 시작 주소 부터 마지막 주소까지의 크기 (= 사이즈)
   
```
Example) 레지스터에 메모리에 있는 데이터 적재 예시

1. PC에서 다음 실행될 명령어를 제어장치가 해석한다.
2. 제어장치는 IP에 해석한 명령어를 실행한다.
3. MAR에 메모리 위치가 저장되고, 메모리에서 데이터를 가져다가 MBR에 옮긴다.
    -> 주소 버스를 통해서 MBR의 저장된 위치 정보를 전달
    -> MMU(Memory Management Unit, MMU) 메모리를 PT에서 VA를 PA로 변환
    -> 변환된 PA에서 데이터 버스를 통해서 데이터를 읽는다
4. MBR에 있는 데이터를 레지스터에 저장(명령어 명시된 레지스터로 이동 -> 범용 레지스터지 않을까?)
```
   
****

### 📌 버스의 종류
- 제어 버스(Control Bus)
  - 어떤 작업을 할지 지시하는 제어 신호를 주고 받는다.
  - 메모리에서 데이터를 가져올 때는 읽기(Read) 신호를 보낸다.
  - 데이터를 메모리에 옮겨 놓을 때는 쓰기(Write) 신호를 보낸다.
  - CPU의 제어장치와 연결되어 있어서 신호가 전달된다.(메모리, 주변 장치들과도 '양뱡향'으로 연결되어 있음)
    - ex1) 메모리에서 오류 발생
    - ex2) 네트워크 카드에 데이터가 도착했다는 신호 
- 주소 버스(Address Bus)
  - 매모리의 데이터를 조작할 때 어느 위치에서 작업할 것인지를 위치 정보를 주고 받는다.
  - 메모리 주소 레지스터와 '단방향' 연결되어 있다.
    - 왜? CPU에서 어느 위치에서 작업을 하라고 위치 정보를 받는거지 주변 기기나 메모리가 주소 버스를 통해서 전해줄 정보는 없음 
- 데이터 버스(Data Bus)
  - 메모리 버퍼 레지스터와 '양방향'으로 연결되어 있다.
  - 주소 버스를 통해 전달 받은 위치 정보를 토대로 데이터를 목적지 까지 이동한다.

※ 대역폭(Bandwidth): 버스에서 한 번에 전달 가능한 데이터의 최대 크기는 CPU가 한 번에 처리할 수 있는 데이터 크기와 같다.  
- 대역폭, 레지스터 크기, 메모리에 한 번에 저장가능한 데이터 크기는 같다.
- CPU가 한 번에 처리 가능한 크기(= 워드, Word)

****

### 📌 메모리
메모리를 이루는 소자 하나의 크기는 1bit 지만 1bit 로는 표현 가능한 데이터는 0과 1이기 때문에 Byte 단위로 저장이 된다.  
하지만 버스의 대역폭에 따라서 한 번에 옮기는 단위가 결정된다. (32 bits = 4 bytes)

![KakaoTalk_Photo_2024-02-09-22-42-22](https://github.com/nashs789/Book-Study/assets/59809278/da812a03-091e-460e-8f69-28e967b215f7)

- 램(Random Access Memory, RAM): 무작위 데이터를 읽어도 위치와 상관 없이 같은 속도로 데이터를 읽음
  - 휘발성 메모리(Volatility Memory)
    - DRAM(Dynamic RAM): 시간이 지나면 사라짐 -> 메인 메모리
    - SRAM(Static RAM): 전력이 공급되는 동안 유지됨 -> 캐시
  - 비휘발성 메모리(Non-Volatility Memory)
- 롬(Read Only Memory, ROM): 전력이 끊겨도 데이터 보관이 가능하지만 한 번 저장하면 바꿀 수 없다 그렇기 때문에 바비오스를 롬에 저장

****
### 📌 메모리와 CPU 속도 차이 개선

느린 입출력장치에서 데이터를 읽는 속도 보다 CPU가 작업을 처리하는 속도가 더 빨라서 발생하는 문제로 CPU가 작업을 다 처리후 잉여 시간이 남기 때문에 최고의 효율을 내지 못하는 상황이 생긴다.

</br>

- 버퍼(Buffer)
  - 하드디스크에 메모리 버퍼를 이용해서 데이터를 한 번에 모아서 옮기는 방법이다.(하드디스크에만 국한된건 아님)
  - 프로그램간 버퍼를 공유해 버퍼가 차면 데이터를 이동한다.
  - ex) 동영상 스트리밍시 네트워크에서 데이터가 넘어오는 시간과 재생되는 시간의 속도 차이
- 스풀(SPOOL)
  - CPU와 입출력장치가 독립적으로 동작하도록 고안된 소프트웨어적 버퍼이다.
  - 프로그램간은 배타적으로 동작한다.
    - 인쇄중 다른 인쇄물이 끼어들 수 없음
  - ex) 워드를 사용하다가 출력을 할 때 출력 명령은 하드디스크의 스풀러 공간에 저장하고 워드를 계속해서 사용할 수 있는 것과 같다.

</br>

- 캐시(Cache)
  - 메모리의 데이터를 미리 가져와서 저장해두는 장소이다.
  - CPU가 앞으로 사용할 것으로 예상되는 데이터를 미리 가져온다.(Prefetch)
  - 캐시는 CPU 내부에 있어 CPU 내부 버스 속도로 동작, 메모리는 시스템 버스 속도로 동작
  - 메모리 접근 전 캐시를 방문하여 원하는 데이터가 있다면 메모리까지 접근하지 않는다.
    - 캐시 히트(Cache Hit): 원하는 데이터가 있는 경우
    - 캐시 미스(Cache Miss): 원하는 데이터가 없는 경우
    - 캐시 적중률(Cache Hit Ratio): 캐시 히트 비율
      - 일반적으로 90% 이상의 적즁률이 나온다.(아마도 메모리가 갖는 지역성 때문이지 않을까?)
  - 캐시 데이터에 대한 조작이 일어난 경우 메모리에도 반영 해야한다.
    - 즉시 쓰기(Write Through): 조작이 일어나면 바로 반영
      - 장점: 메모리와 캐시의 데이터 동기화
      - 단점: 계속되는 전송으로 생기는 오버헤드
    - 지연 쓰기(Write Back): 변경된 내용을 모아서 반영(= Copy Back)
      - 장점: 전송 횟수가 줄어 성능 향상
      - 단점: 데이터 동기화가 안되어 데이터 불일치 발생

****

# **[ 🔑 키워드 ]**
- 폰노이만 구조(Von Neumann Architecture)
- 클록(Clock)
- 헤르츠(Hz)
- 레지스터(Register)
- 시스템 버스(System Bus)
- 메모리 관리 장치(MMU)
- 버퍼(Buffer)와 스풀(Simultaneous Peripheral Operation On-Line, SPOOL)
