# **Chapter08 - 가상 메모리의 기초**

# **[ 📋 목차 ]**
- 가상 메모리의 개요
- 페이징 기법
- 세그먼테이션 기법
- 세그먼테이션-페이징 혼용 기법
- 캐시 매핑 기법

****

# **[ 🗂️ 정리 ]**
## 📌 <b>가상 메모리의 개요</b>

### ⚙ <b>가상 메모리 시스템</b>
가상 메모리는 크기가 다른 물리메로에서 일관되게 프로세스를 실행할 수 있는 기술이다.  
컴퓨터마다 다른 메모리 크기를 갖는데 물리 메모리에만 의존한다면 어떤 프로그램은 돌고, 어떤 프로그램은 동작하지 않는 상황이 생길 수 있고, 프로그래머 또한
물리 메모리를 고려하여 프로그래밍 해야한다.
  
현대 메모리의 가장 큰 특징은 프로그램이 올라갈 메모리의 위치를 신경쓰지 않고 프로그래밍할 수 있다는 것이다.  
이를 도와주는게 <b>가상 메모리</b> 이다.  
우리는 가상 메모리가 있어서 프로그램이 물리 메모리의 어느 위치인지, 물리 메모리의 크기가 몇인지 고려하지 않아도 된다.

가상 메모리 시스템에서 메모리 관리자는 물리 메모리와 스왑 영역을 합쳐서 프로세스가 사용하는 가상 주소를 실제 물리 주소로 변환하는데 이러한 작업을
'동적 주소 변환(Dynamic Address Translation)' 이라고 한다.

|구분|가상 메모리|물리 메모리|
|:---:|:---:|:---:|
|최대 메모리 크기|CPU의 비트 값에 의존|CPU의 비트 값에 의존|
|메모리 분할 방식|세그먼테이션|가변 분할 방식|
|-|페이징|고정 분할 방식|
|-|세그먼테이션-페이징 혼용 기법|-|
|주소 지정 방식|가상 주소|절대, 상대 주소|

### ⚙ <b>매핑 테이블의 필요성과 역할</b>
가상 주소는 매핑 테이블에 작성되어 관리되는데 가상 주소는 물리 주소 혹은 스왑 영역 중 한 곳에 위치하며, 메모리 관리자는 가상 주소와 물리 주소를
1:1 로 매핑한다.
  
[그림 8-4] p.383
  
페이징 기법과 세그먼테이션 기법 두 기법 전부 똑같은 방법으로 매핑되며 페이징 기법에서는 '페이지 매핑 테이블(Page Mapping Table)' 또는 '페이지 테이블(Page Table)'
이라고 하며 세그먼테이션 기법은 '세그먼테이션 매핑 테이블(Segmentation Mapping Table)' 또는 '세그먼테이션 테이블(Segmentation Table)' 이라고 한다.

****

## 📌 <b>페이징 기법</b>

### ⚙ <b>페이징 기법의 구현</b>

[그림 8-5] p.385 

가상 주소를 고정 분할해서 나눴을 때 분할된 각 영역은 '페이지(Page)' 라고 부르며, 물리 메모리의 각 영역은 '프레임(Frame)' 이라고 부른다. (페이지와 프레임의 크기는 같다.)
  
그림을 보면 페이지와 프레임이 1:1로 매핑되어 있지만, 페이지 5번 같은 경우에는 매핑된 프레임이 존재하지 않는데 이런 경우 해당 페이지에 invalid 표시가 되어
있고, 스왑 영역에 존재 한다는 의미다.
  
주소를 변환하는 과정은 크게 어렵지 않다.  
👉 접근하고자 하는 가상 주로에 접근해 해당 주소를 갖는 페이에 찾아가서 매핑된 프레임을 얻으면 된다. (R/W 작업을 하면 된다.)

```
[ 정형화된 주소 변환 ]

VA = <P, D>

- VA: Virture Address
- P: Page
- D: Distance (Offset을 의미한다.)

PA = <F, D>

- PA: Physical Address
- F: Frame
```

위 공식을 생각해보면 페이지가 총 10개 있다고 가정하고, 각 페이지들이 표현 가능한 주소는 10개다.  
이 상태에서 내가 8번 주소에 Write 작업을 하고 싶다면 가상 주소는 VA = <0, 8> 로 표현이 될테고, 0번째 페이지에 오프셋 계산된 주소 값이다.

[그림8-7] p.388

그림을 보면 page-frame 은 매핑정보를 통해서 얻어오며, distance 는 그대로 사용하는데 이는 페이지와 프레임이 표현하는 주소 크기가 같기 때문이다.  
  
페이지 테이블에서 각각의 한 줄은 '페이지 테이블 엔트리(Page Table Entry)' 이고, 페이지 테이블은 페이지 테이블 엔트리의 집합이라고 보면 된다.
  
또 페이지 넘버링은 되어있지 않은데 번호가 0부터 순서대로 되있기 때문에 프레임에 대한 매핑 정보만 있으면 된다.

하지만 컴퓨터는 2진법을 사용해서 표기하기 떄문에 분할되는 단위는 OS 마다 다르다.   
👉 단위는 다르지만 구하는 공식은 있다.

```
P = 가상 주소 / 한 페이지의 크기 (몫)
D = 가상 주소 % 한 페이지의 크기 (나머지)
```

한 페이지가 4KB 기준으로 897654는 <219, 630> 으로 표현된다.

[그림8-8] p.389

... 페이지 & 주소 계산 방법 부터 정리하면 될 듯

### ⚙ <b>페이징 기법의 주소 변환</b>
### ⚙ <b>페이지 테이블 관리</b>
### ⚙ <b>페이지 테이블 매핑 방식</b>

****

## 📌 <b>세그먼테이션 기법</b>
### ⚙ <b>세그먼테이션 기법의 구현</b>
### ⚙ <b>세그먼테이션 기법의 주소 변환</b>

****

## 📌 <b>세그먼테이션-페이징 혼용 기법</b>
### ⚙ <b>메모리 접근 권한</b>
### ⚙ <b>세그먼테이션-페이징 혼용 기법의 도입</b>
### ⚙ <b>세그먼테이션-페이징 혼용 기법의 주소 변환</b>

****

## 📌 <b>캐시 매핑 기법</b>
### ⚙ <b>캐시 직접 매핑</b>
### ⚙ <b>캐시 연관 매핑</b>
### ⚙ <b>캐시 집합-연관매핑</b>

****