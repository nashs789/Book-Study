# **Chapter03 - 프로세스와 쓰레드**

# **[ 📋 목차 ]**
- 프로세스의 개요
- 프로세스 제어 블록과 문맥 교환
- 프로세스의 연산
- 스레드
- 동적 할당 영역과 시스템 호출

****

# **[ 🗂️ 정리 ]**
### 📌 프로세스란

#### ⚙︎ 프로세스
폰노이만 구조에서 프로그램이 실행 된다는 것은 해당 코드가 메모리에 올라와서 작업이 진행된다는 의미이다.  
저장장치에 저장되어 있는 상태는 '정적' 상태이며, 실행을 위해 메모리에 올라온 상태는 '동적' 상태이다.  
프로그램은 누군가가 작성한 코드이며, 이 프로그램을 실행되면 프로세가 된다.

#### ⚙︎ 시분할 시스템
CPU와 한정된 자원을 이용해서 여러개의 프로세스를 실행 시키기 위해서 CPU의 시간을 쪼개어 여러 프로세스에 배분해 동시에 실행 되는것 처럼 보이게 하는 것.

#### ⚙ PCB(Process Control Block)
구성 정보
- 프로세스 식별자(Process IDentification, PID)
  - 각 프로세스를 고유하게 식별하는 번호, 프로세스간 통신, 리소스 할당, 권한 관리등을 식별번호로 기반으로 수행한다.
  - 고유하게 사용되나 프로세스가 종료된 후에는 다른 프로세스가 폐기된 PID를 할당 받아서 사용 가능하다.
- 프로세스 상태(Process State)
  - 생성(Create): 시스템에 의해서 PID가 할당 및 PCB 생성, 실행 준비는 되지 않은 상태이다.
  - 준비(Ready): CPU에서 실행될 준비가 된 상태로 스케줄러에 따라서 실행 순서가 결정된다.
    - 준비 상태의 프로세스중 실행할 프로세스를 선정하는 역할은 스케줄러(Scheduler)가 담당한다.
    - 준비 상태의 프로세스를 실행 상태로 바꾸는 작업을 디스패치(Dispatch)라고 한다.
  - 실행(Running): 프로세스가 CPU를 할당 받아서 실행중인 상태이다. (CPU는 프로세스 코드 실행)
    - 프로세스가 배당된 작업 시간을 타임 슬라이스라고 하고, 주어진 시간내에 작업을 끝내지 못하면(Time Out) 준비 상태로 돌아간다.
    - 다른 하드웨어를 통한 작업이 필요한 경우 작업이 끝날 때 까지 대기 상태로 변경하고 외부로 부터 인터럽트를 받게 된다면 준비 상태로 돌린다.
    - CPU의 개수 만큼 실행할 수 있다.
  - 대기(Waiting): 특정 이벤트에 의해서 작업이 중지된 상태로, 다시 준비 상태로 전활될 수 있다.
    - 대기 상태의 프로세스는 sleep하게 되고, 요청한 작업이 완료되면 wakeup시켜 준비 상태로 이동한다.
  - 종료(Terminated): 프로세스 실행이 완료되고 제거되는 상태이다.
  - 휴식(Pause): 프로세스가 메모리에 있지만 멈춘 상태
  - 보류(Suspend): 스왑 영역에 보관된 상태
- 프로그램 카운터(Program Counter, PC)
  - 다음에 실행할 명령어의 주소를 저장하는 레지스터이다.
  - 다음 명령어를 실행할지 결정하는 명령어 순서 제어의 역할을 한다.
  - 컨텍스트 스위칭시 PC에 저장되어 있는 명령어는 PCB에 저장된다. 
- CPU 레지스터 및 일반 레지스터
  - 컨텍스트 스위칭시 CPU 레지스터 값들은 PCB에 저장된다.
- CPU 스케줄링 정보
  - 자원을 어떻게 할당 받을지 결정하는 역할을 하는 정보를 저장한다.
  - 우선순위(Priority)
  - 프로세스 상태(Process State)
  - CPU 점유 시간(CPU Time): 알고리즘에 이용되는 정보
  - 대기 시간(Waiting Time): 준비 큐에서 대기한 시간
  - 프로세스 도착 시간(Arrive Time): 준비 큐에 도착한 시간 
  - 실행 종료 시간(Burst Time): 프로세스가 CPU를 사용 할 예상 시간 
- 메모리 관리 정보
  - 프로세스가 사용하는 메모리 영역의 위치, 접근 권한
- 프로세스 계정 정보
- 입출력 상태 정보
  - 프로세스에 할당된 I/O 장치 목록
  - 파일 목록 
- 포인터
  - 데이터 구조, 다른 프로세스, 자원 등 시스템에서 필요로 하는 정보를 참조하는 포인터들을 관리한다.
  - 준비, 대기 상태는 큐 자료구조로 관리 되는데 제어 블록의 첫 번째가 연결되어 구성된다.
  
PCB는 프로세스를 위해서 관리되는 자료구조이기 때문에 운영체제 영역에서 관리된다.

****

### 📌 프로세스 제어 블록과 문맥 교환

#### ⚙ 프로세스 제어 블록 - 포인터의 역할
시스템에 다양한 입출력 장치가 존재하기 때문에 하나의 큐에 모아두면 입출력 장치로부터 인터럽트가 발생 했을 때 매번 선형적으로 탐색해야 한다.
```
대기 큐
입출력 대기큐 - head -> P1 -> p2 -> p3 -> p4 -> tail
```
그렇기 때문에 입출력 장치에 따라 큐를 갖고, 같은 입출력을 요구한 프로세스끼리 모아 둔다.
```
대기큐
하드디스크 대기큐: head -> P1 -> p6 -> p9 -> p12 -> tail
CD-ROM 대기큐:  head -> P5 -> p2 -> p3 -> p4 -> tail
LAN 대기큐:     head -> P10 -> p11 -> p7 -> p8 -> tail
```

#### ⚙ 문맥 교환(Context Switching)
CPU를 점유하던 프로세스가 나가고 새로운 프로세스가 점유하는 작업을 말한다.

- 문맥 교환 절차
1. P1이 '실행' 상태에서 'Time Out' 으로인해 '준비' 상태로 들어간다. (타임 아웃이 다른 이유도 있음 -> 인터럽트)
2. 준비 상태로 들어가면서 P1의 상태를 PCB1 에 저장한다.
3. PCB2에 정보를 CPU 레지스터에 옮기면서 P2가 CPU 를 점유하게 되며 '실행' 상태가 된다.

****

### 📌 프로세스의 연산
#### ⚙ 프로세스의 구조
- 코드 영역(Code Area 또는 Text Area): 프로그래머가 작성한 코드이며 읽기 전용이다.
- 데이터 영역(Data Area): 코드가 실행 되면서 사용하는 변수나 파일 등 각종 데이터 영역이며 읽기, 쓰기가 가능하다.
- 스택 영역(Stack Area): 프로세스를 동작하기 위해서 사용되는 영여(운영체제가 프로세스를 동작하기 위해 사용)
  - ex) 함수 호출(Function call)을 하게 되면 다시 돌아오기 위해서 이전 실행 명령어의 주소가 필요

#### ⚙ 프로세스의 생성과 복사
매번 새로운 프로세스를 생성하는 작업은 무거운 작업이기 때문에 이미 실행 중인 프로세스로부터 복사하는게 가능하다.

- fork(): 프로세스 복사 시스템 함수로 생성된 두 프로세스는 부모-자식 관계를 갖는다.
  - PID를 제외한 똑같은 상태의 프로세스를 만든다.
  - 부모-자식 관계는 CPID-PPID로 맺어진다.
  - 부모가 사용하던 변수, 파일등 전부 복사된다.
  - 장점
    - 빠른 속도: 메모리를 복사하는 작업이기 때문에 빠르다.
    - 추가 작업이 필요 없다: 부모의 상태를 그대로 복사하기 때문에 별도의 원하는 작업 없이 바로 수행 가능
    - 효율성: 자식이 종료되고, 부모 프로세스가 종료 되면서 자원을 정리하면 된서 사용하던 메모리를 잘 정리 가능(파일 시스템 관련)
- exec(): 프로세스의 현재 실행중인 프로그램을 새로운 프로그램으로 대체한다.
  - 주 목적: 프로세스의 구조체를 활용하기 위함
    - 새로운 프로세스를 만드는 작업은 PCB 를 만들고, 메모리를 확보하는 과정이 있어야 하고, 종료시 메모리 정리를 위해 부모-자식 관계를 맺어야 하지만 exec()를 호출하게 되면 이미 만들어진 프로세스를 이용할 수 있다.(새로운 코드 영역만 필요)
    - 동작 과정
      - 코드 영역: 새로운 코드로 대체
      - 데이터 영역: 새로운 변수로 채워진다.
      - 스택 영역: 리셋
      - PC, 레지스터, 파일 정보 리셋

#### ⚙ 프로세스의 계층 구조
OS는 프로세스를 효율적으로 관리하기 위해서 init 프로세스 생성 후 나머지 프로세스는 init 프로세스의 자식으로 만든다.  
운영체제의 모든 프로세스는 init 프로세스의 자식으로 계층형 구조를 갖는다.

- 계층형 구조의 장점
  - 작업 병렬처리
    - 하나의 프로세스에 대한 작업으로 여러개의 작업이 들어온다면, 하나씩 처리해야 하지만, fork()를 통해 프로세스를 복사해서 작업 배분하면 동시에 처리가 가능해진다.
    - ex) login -> shell 두 프로세스가 순처적으로 실행 된다면
      1. init 프로세스를 통해서 fork()된 프로세스 login이 작업 할당
      2. login 프로세스가 작업이 끝나고 프로세스를 exec() 호출로 새로 생성하지 않고, shell 프로세스가 자원을 재활용 하도록 한다.


# **[ 🔑 키워드 ]**