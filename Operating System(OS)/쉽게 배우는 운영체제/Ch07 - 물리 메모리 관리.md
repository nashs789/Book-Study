# **Chapter07 - 물리 메모리 관리**

# **[ 📋 목차 ]**
- 메모리 관리의 개요
- 메모리 주소
- 단일 프로그래밍 환경에서의 메모리 할당
- 다중 프로그래밍 환경에서의 메모리 할당
- 컴피알과 메모리 관리

****

# **[ 🗂️ 정리 ]**︎
## 📌 메모리 관리의 개요

### ⚙ <b>메모리 관리의 복잡성</b>

- 메모리 주소 번지는 0부터 시작한다.
- 메모리 주소 레지스터(MAR) 를 사용해서 메모리에서 데이터를 가져오거나, 메모리에 적재
- 폰노이만 구조에서 메모리는 유일한 작업 공간이며, 모든 프로그램은 메모리에 올라와야 실행 가능

왜 복잡할까?  
👉 시분할 시스템에서 OS를 포함한 모든 프로그램이 메모리에 실행되기 떄문에 복잡하다.   
👉 복잡한 메모리 관리는 메모리 관리 시스템(Memory Management System, MMS) 가 담당한다.

### ⚙ <b>메모리 관리의 이중성</b>

이중성?  
👉 MMS 입장에서는 메모리를 효율적으로 사용하고 싶고, 프로세스 입장에서는 메모리를 혼자서 사용하고 싶다.

- 프로세스를 더 큰 공간으로 옮긴다 -> 빈 공간 처리
- 빈 공간이 여러개 생긴다 -> 합친다
  
위에서 나오는 메모리 공간을 작업하는 것은 실제로는 매우 복잡하다.

### ⚙ <b>소스코드의 번역과 실행</b>
1. <b>컴파일러(Compiler)와 인터프리터(Interpreter)</b>  

👉 0과 1로 되어있는 기계어는 인간이 이해하고 사용하기 어렵기 때문에 언어를 대신해서 사용하고, 기계어와 가장 유사한 언어인 어셈블리어가 있고
컴퓨터의 동작을 가장 직접적으로 표현한 언어로 <b>저급 언어(Low Level Language)</b>라고 한다.

반대의 개념은 <b>고급 언어(High Level Language)</b> 라고 부른다.  
이렇게 고급 언어로 작성된 코드를 컴퓨터가 실행할 수 있는 기계어로 번역하는 프로그램이 컴파일러와 인터프리터다.
  
- 컴파일러: 소스코드를 컴퓨터가 실행할 수 있는 기계어로 번역 후 한 번에 실행한다.
- 인터프리터: 소스코드를 한 라인씩 번역하여 실행한다.

### ⚙ <b>컴파일러의 목적</b>
- 오류 발견: 오류 검출 후 실행 시 문제가 없도록 하는 것이 목적이며 오류 검출을 위해서 심볼 테이블(Symbol Table)을 이용한다.
  선언부에 명시한 변수의 이름과 타입별로 모아놓은 테이블로 검사를 진행한다.
- 코드 최적화: 중복 사용을 합치거나, 사용하지 않는 변수를 제거 하면서 최적화를 진행한다.

### ⚙ <b>컴파일러와 인터피르터 차이</b>
'컴파일러' 는 코드가 실행되기 전에 소스코드를 점검하여 오류를 검출하고, 불필요한 부분을 정리하여 최적화된 파일을 만든다.

****

## 📌 메모리 주소
### ⚙ <b></b>

****

## 📌 단일 프로그래밍 환경에서의 메모리 할당
### ⚙ <b></b>

****

## 📌 다중 프로그래밍 환경에서의 메모리 할당
### ⚙ <b></b>

****

## 📌 컴피알과 메모리 관리
### ⚙ <b></b>