# **Chapter07 - 물리 메모리 관리**

# **[ 📋 목차 ]**
- 메모리 관리의 개요
- 메모리 주소
- 단일 프로그래밍 환경에서의 메모리 할당
- 다중 프로그래밍 환경에서의 메모리 할당
- 컴피알과 메모리 관리

****

# **[ 🗂️ 정리 ]**︎
## 📌 메모리 관리의 개요

### ⚙ <b>메모리 관리의 복잡성</b>

- 메모리 주소 번지는 0부터 시작한다.
- 메모리 주소 레지스터(MAR) 를 사용해서 메모리에서 데이터를 가져오거나, 메모리에 적재
- 폰노이만 구조에서 메모리는 유일한 작업 공간이며, 모든 프로그램은 메모리에 올라와야 실행 가능

왜 복잡할까?  
👉 시분할 시스템에서 OS를 포함한 모든 프로그램이 메모리에 실행되기 떄문에 복잡하다.   
👉 복잡한 메모리 관리는 메모리 관리 시스템(Memory Management System, MMS) 가 담당한다.

### ⚙ <b>메모리 관리의 이중성</b>

이중성?  
👉 MMS 입장에서는 메모리를 효율적으로 사용하고 싶고, 프로세스 입장에서는 메모리를 혼자서 사용하고 싶다.

- 프로세스를 더 큰 공간으로 옮긴다 -> 빈 공간 처리
- 빈 공간이 여러개 생긴다 -> 합친다
  
위에서 나오는 메모리 공간을 작업하는 것은 실제로는 매우 복잡하다.

### ⚙ <b>소스코드의 번역과 실행</b>
1. <b>컴파일러(Compiler)와 인터프리터(Interpreter)</b>  

👉 0과 1로 되어있는 기계어는 인간이 이해하고 사용하기 어렵기 때문에 언어를 대신해서 사용하고, 기계어와 가장 유사한 언어인 어셈블리어가 있고
컴퓨터의 동작을 가장 직접적으로 표현한 언어로 <b>저급 언어(Low Level Language)</b>라고 한다.

반대의 개념은 <b>고급 언어(High Level Language)</b> 라고 부른다.  
이렇게 고급 언어로 작성된 코드를 컴퓨터가 실행할 수 있는 기계어로 번역하는 프로그램이 컴파일러와 인터프리터다.
  
- 컴파일러: 소스코드를 컴퓨터가 실행할 수 있는 기계어로 번역 후 한 번에 실행한다.
- 인터프리터: 소스코드를 한 라인씩 번역하여 실행한다.

### ⚙ <b>컴파일러의 목적</b>
- 오류 발견: 오류 검출 후 실행 시 문제가 없도록 하는 것이 목적이며 오류 검출을 위해서 심볼 테이블(Symbol Table)을 이용한다.
  선언부에 명시한 변수의 이름과 타입별로 모아놓은 테이블로 검사를 진행한다.
- 코드 최적화: 중복 사용을 합치거나, 사용하지 않는 변수를 제거 하면서 최적화를 진행한다.

### ⚙ <b>컴파일러와 인터피르터 차이</b>
'컴파일러' 는 코드가 실행되기 전에 소스코드를 점검하여 오류를 검출하고, 불필요한 부분을 정리하여 최적화된 파일을 만든다.  
'인터프리터' 는 한 줄씩 위에서 아래로 실행되기 때문에 반복하거나, 불필요한 부분을 확인할 수 없다.

### ⚙ <b>컴파일 과정</b>
```
소스코드 -> 목적 코드(Object Code) -> Library Linking - Execute
```

- 소스코드 작성 및 컴파일: 소스 코드가 컴파일되면 목적 코드가 된다.
- 목적 코드와 라이브러리 연결: 라이브러리 코드를 목적 코드에 삽입하여 최종 실행 파일을 만든다.
- 동적 라이브러리를 포함하여 최종 실행: 라이브러리 코드를 비워두고 실행 한 뒤 컴파일한 후에 실행 코드를 라이브러리에서 가져와서
실행하는 방법을 사용할 때 사용되는 라이브러리가 동적 라이브러리(Dynamic Library)라고 부르고, 윈도우에서 동적 라이브러리 파일을
Dynamic Link Loader, DLL 라고 부른다.

### ⚙ <b>메모리 관리자의 역할</b>
메모리 관리를 담당하는 관리 역할은 MMU(Memory Manage Unit, MMU) 가 담당하는데 메모리에 가져오기(Fetch), 배치(Placement),
재배치(Replacement) 작업을 수행한다.

- 가져오기: 프로세스와 데이터를 메모리로 가져오는 작업(모든 데이터가 아닌 일부만 가져올 수 있음 -> 스왑 디스크와 연관된 내용일듯)
  - 정책: 어느 시점에 메모리로 가져올까?
    - 프로세스 요청 시점
    - 예상되는 데이터 미리 가져오기(Prefetch)
- 배치: 프로세스와 데이터를 배치할 메모리 위치를 결정하는 작업으로 메모리를 어떻게 잘라서 사용할지에 따라서 메모리 관리 복잡성이 달라진다.(메모리 할당과
  다편화에 연관된 내용일듯)
  - 정책: 어떤 위치에 가져다 놓을까?
    - 페이징(Paging): 메모리를 같은 크기로 자르는 것
    - 세그먼테이션(Segmentation): 프로세스 크기에 맞춰서
- 재배치: 메모리가 가득 찼다면 메모리상에 있는 프로세스를 하드디스크로 옮겨야 새로운 프로세스가 동작 가능하기 때문에 오래된 프로세스를 내보내는 작업(스왑)
  - 정책: 교체 알고리즘(Replacement Algorithm) 사용

****

## 📌 메모리 주소

### ⚙ <b>32bit CPU 와 64bit CPU 차이</b>
CPU 의 비트는 한 번에 다룰 수 있는 데이터의 최대 크기를 의미한다.(32bit 는 32bit 를 최대로 한 번에 다룰 수 있다.)  

- 32bit CPU 내의 레지스터는 32bit 이다.
- 32bit CPU 의 산술 논리 연산장치도 32bit 처리를 할 수 있다.
- 버스들의 대역폭도 32bit 이다.
- 32bit CPU 가 표현 가능한 메모리 주소 번지는 0 ~ 2^32-1(00000000 ~ FFFFFFFF) 까지로 약 4GB 이다.

실제로 64bit CPU 가 표현 가능한 메모리 번지수는 16,777,216TB(18EB) 까지 가능하다.  
이렇게 나누어논 메모리 주소를 하드웨어 입장에서는 물리 주소 공간(Physical Address Space), 사용자 입장에서 논리 주소 공간(Logical Address Space) 라 한다.

```
2^10 -> 1KB
2^20 -> 1MB
2^30 -> 1GB
2^40 -> 1TB
2^50 -> 1PB
2^60 -> 1EB
```

### ⚙ <b>절대 주소와 상대 주소</b>
먼저 메모리 상에서 OS와 사용자 영역이 나뉘어서 OS 영역이 침범되지 않도록 분리되어 있다.  
OS 영역이 침범당하지 않게 하기 위해서 하드웨어 '경계 레지스터' 의 도움을 받는다.

- 절대 주소(Absolute Address): 컴파일 시점에는 메모리상에 올리지 않기 때문에 임의로 0번부터 배정하고 실제 프로세스가 실행되면서 메모리상에
올라갈 때 메모리 만큼의 주소를 더해서 계산한다.
  ```
  0번 주소로 배정하고 메모리상에 400번에 올라가게 되면 배정한 모든 메모리를 400 더해서 실제 하드웨어상의 주소로 변경한다.
  (실제 하드웨어 주소는 컴포터에 꽂혀있는 RAM의 실제 주소를 말한다.)
  ```
- 상대 주소(Relative Address): 사용자 입장에서 절대주소는 위험하다. 운영체제가 업데이터 되어 사용되는 메모리 용량이 커진다면? 실수 혹은 고의적으로
OS의 영역을 침범할 여지가 있기 때문이다. 그래서 절대 주소와는 다르게 매핑된 상대 주소를 사용한다.
  ```
  OS가 399번 까지 주소를 사용하고 있다면 상대 주소는 400을 다른 주소로 매핑해서 사용한다. ex) 400 -> 0 
  ```

### ⚙ <b>상대 주소를 절대 주소로 변환하는 과정</b>
상대 주소를 사용하면 실제로 접근하기 위해서는 물리 주소로 변환 해야한다.
  
> 책에는 가볍게 쓰여져 있지만 MMU 에 의해서 Page Table 참조해 물리 주소와 논리 주소를 변환하는 과정을 생략 했거나 
> 뒤에서 등장할 듯 (Page Fault 등)

****

## 📌 단일 프로그래밍 환경에서의 메모리 할당
### ⚙ <b></b>

****

## 📌 다중 프로그래밍 환경에서의 메모리 할당
### ⚙ <b></b>

****

## 📌 컴피알과 메모리 관리
### ⚙ <b></b>