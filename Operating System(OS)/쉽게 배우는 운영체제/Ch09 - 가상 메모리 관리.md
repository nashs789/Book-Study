# **Chapter09 - 가상 메모리 관리**

# **[ 📋 목차 ]**
- 요구 페이징
- 페이지 교체 알고리즘
- 스레싱과 프레임 할당
- 프레임 관련 이슈

****

# **[ 🗂️ 정리 ]**
## 📌 <b>요구 페이징(Demand Paging)</b>
프로세스가 필요로 하는 데이터를 요청할 때 메모리로 가져오는 방법이다.

### ⚙ <b>요구 페이징의 개요</b>
> 컴퓨터를 오랫동안 켜두었을 때 오랫동안 사용하지 않았지만 켜둔 프로세스와 좀비 프로세스들 때문에
> 느려지는 현상이 발생한다.

메모리 효율을 위해서 용량이 큰 프로세스를 실행할 때 프로세스를 구성하는 모든 모듈을 메모리에 올리지 않고, 필요할 때 메모리에서 불러온다.

- 메모리 효율성: 사용하지도 않는 데이터를 메모리에 올려둘 필요 없음
- 속도 향상: 필요한 모듈만 올려서 바로 실행될 수 있도록 한다.

요구할 때 가져오는게 아닌 미리 가져오는 것은 캐시(Cache) 라고 한다.  
캐시 히트가 되는 경우 상당한 성능 향상을 기대할 수 있지만 히트를 못하는 경우 리스크 때문에 요구 페이지 기법을 기본으로 사용한다.

### ⚙ <b>페이지 테이블 엔트리의 구조</b>
가상 메모리의 크기는 물리 메모리와 스왑 영역을 합친 것이다.
  
페이지가 스왑 영역에 있다는 경우는 두 가지로 나눌 수 있다.

- 요구 페이징으로 처음부터 물리 메모리로 올라가지 못한 경우
- 스압 아웃으로 쫓겨난 경우

페이지의 위치를 알 수있게 유효 비트를 사용해서 표시한다.
페이지 테이블 엔트리의 구성은 다음과 같다.

```
| 페이지 번호 | a | m | v | r | w | x | 프레임 번호 |
           ↳        플래그 비트      ↲ ↳ 주소 필드 ↲
   
a: access bit(= reference bit)
m: modified bit(= dirty bit)
v: valid bit(= present bit)
r: read bit    ⤵
w: write bit   (= rights bit)
x: excute bit  ⤴       
```

- 접근 비트: 메모리에 올라온 후 사용된 적이 있는지(= 참조 비트)
- 변경 비트: 메모리에 올라온 후 데이터 변경이 있었는지
- 유효 비트: 메모리에 존재하는지
- 읽기, 쓰기, 실행: 말 그대로 권한에 대한 비트(= 권한 비트)

### ⚙ <b>페이지 부재</b>
유효 비트가 1로 되어있어 실제 메모리 상에 페이지가 없다면 페이지 부재(Page Fault) 라고 한다.  
Page Fault 가 발생하면, 스왑 영역에서 물리 메모리로 데이터를 가져와야 한다.

[그림9-6] p.428

그림과 같이 빈 프레임이 없다면 메모리에서 가져와서 프레임에 할당하면 되지만 빈 프레임이 없을 경우 페이지 교체 알고리즘(Page Replacement Algorithm)
을 통해서 스왑 아웃이 될 대상 페이지를 선정하는데 이 떄 페이지를 대상 페이지(Victim Page) 라고 한다.

[그림9-7] p.429

위 그림은 프레임 하나를 스왑 아웃을 통해서 내보내고 새로운 데이터를 스왑인 하는 과정이다.

- Segmentation Fault: 프로세스가 할당 받은 영역 밖의 메모리를 참조하거나, 권한이 없는 곳을 접근할 때
- Page Fault: 물리 메모리에 참조하고자 하는 데이터가 없을 때

### ⚙ <b>지역성(Locality)</b>
스왑이 발생하는 경우 가능하면 앞으로 사용하지 않을 페이지를 쫓아내는 것이 당연히 좋다.  
그런 이유로 페이지를 쫓아내는 경우 페이지 교체 알고리즘은 지역성을 바탕으로 실행된다.

- 공간의 지역성(Spatial Locality): 현재 위치에서 가까운 데이터에 위치할 확률이 더 높다.
- 시간의 지역성(Temporal Locality): 가장 가까운 시간대에 접근한 데이터가 사용될 확률이 더 높다.
- 순차적 지역성(Sequential Locality): 프로그래밍은 처음에서 마지막 순서로 진행되는 경향이 있다는걸 의미한다.

지역성을 이용하는 가장 대표적인 장치로 캐시가 있으며, goto 문 사용을 지양하라는 의미도 지역성 때문이다.

****

## 📌 <b>페이지 교체 알고리즘</b>

### ⚙ <b>페이지 교체 알고리즘의 개요</b>
```
Page Fault -> 스왑 영역에서 메모리로 데이터 가져옴
```

이 상황에서 메모리가 가득 찼을 경우 어느 페이지를 교체할지 정하는 알고리즘으로 앞으로 사용할 가능성이 적은 페이지를 대상으로 선정하는 걸 목표로한다.

|종류|알고리즘|특징|
|:---:|:---:|:---:|
|간단한 알고리즘|무작위|무작위로 대상 페이지 선정|
|-|FIFO|가장 먼저 들어온 페이지 선정|
|이론적 알고리즘|Optimal|미래 접근 패턴을 보고 선정|
|최적 근접 알고리즘|LRU|시간적으로 멀리 떨어진 페이지 선정|
|-|LFU|사용 빈도가 적은 페이지 선정|
|-|NUR|최근에 사용한 적이 없는 페이지 선정|
|-|FIFO 변형|FIFO 알고리즘 변형|

### ⚙ <b>Random</b>
무작위 페이지 교체 알고리즘(Random Page Replacement Algorithm) 은 이름 그대로 스왑 영역으로 쫓아낼 대상 페이지를 특별한 로직 없이
무작위로 선정하기 떄문에 지역성에 대해서 전혀 고려되지 않은 알고리즘이다.

### ⚙ <b>FIFO(First In, First Out)</b>
선입 선출 알고리즘으로 가장 먼저 들어온 페이지를 쫓아내는 방식이기 때문에 선입선출 알고리즘인 큐(Queue)를 이용해서 구현한다.

[그림9-10] p.434

F -Page Fault, S - 메모리에 존재   
그림을 보면 처음으로 스왑되는 순간은 4번째로 'D' 를 참조했지만 메모리상에 올라와있지 않기 때문에 가장 먼저 들어온 'A'를 스왑 아웃 시킨다.
  
```
총 요구: 10번
Page Fault: 7번
```

해당 알고리즘은 시간적 지역성만 보면 오래된 알고리즘을 Victim 으로 선정하니 괜찮지만, 오래되었지만 자주 사용되는 페이지도 스왑 아웃 시키기 때문에 최적의
알고리즘이라고 볼 수 없다.   

시간과 상관없이 자주 쓰이는 페이지가 있는 케이스도 고려해야한다. 

### ⚙ <b>Optimal</b>
최적 페이지 교체 알고리즘으로 앞으로 사용되지 않을 페이지를 스왑 아웃 하는 알고리즘이다.  
설명에서 알 수 있듯이 미래에대한 정보를 알 수 있어야 가능한 알고리즘이기 때문에 구현이 불가능하다.
  
이론적으로 완벽한 알고리즘이라고 할 수 있다.

### ⚙ <b>LRU(Least Recently Used)</b>
최적 근접 알고리즘(Optimal Approximation Algorithm)중 하나로 최근 최소 사용 페이지 알고리즘이다.  
메모리에 올라온 후 가장 오랫동안 사용되지 않은 페이지를 Victim 으로 선정하는 알고리즘이다.
  
구현 방식에는 여러가지 방법이 있다.

#### 👉 페이지 접근 시간 기반 구현

#### 👉 카운터에 기반한 구현

#### 👉 참조 비트 시프트 방식

### ⚙ <b>LFU(Least Frequently Used)</b>
### ⚙ <b>NUR(Not Used Recently)</b>
### ⚙ <b>Second Chance</b>
### ⚙ <b>Clock</b>

****

## 📌 <b>스레싱과 프레임 할당</b>

### ⚙ <b>스레싱</b>
### ⚙ <b>정적 할당</b>
### ⚙ <b>동적 할당</b>

****

## 📌 <b>프레임 관련 이슈</b>

### ⚙ <b>전역 교체와 지역 교체</b>
### ⚙ <b>페이지 테이블 크기</b>
### ⚙ <b>쓰기 시점 복사</b>
### ⚙ <b></b>