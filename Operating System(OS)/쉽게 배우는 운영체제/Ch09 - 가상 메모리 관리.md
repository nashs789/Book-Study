# **Chapter09 - 가상 메모리 관리**

# **[ 📋 목차 ]**
- 요구 페이징
- 페이지 교체 알고리즘
- 스레싱과 프레임 할당
- 프레임 관련 이슈

****

# **[ 🗂️ 정리 ]**
## 📌 <b>요구 페이징(Demand Paging)</b>
프로세스가 필요로 하는 데이터를 요청할 때 메모리로 가져오는 방법이다.

### ⚙ <b>요구 페이징의 개요</b>
> 컴퓨터를 오랫동안 켜두었을 때 오랫동안 사용하지 않았지만 켜둔 프로세스와 좀비 프로세스들 때문에
> 느려지는 현상이 발생한다.

메모리 효율을 위해서 용량이 큰 프로세스를 실행할 때 프로세스를 구성하는 모든 모듈을 메모리에 올리지 않고, 필요할 때 메모리에서 불러온다.

- 메모리 효율성: 사용하지도 않는 데이터를 메모리에 올려둘 필요 없음
- 속도 향상: 필요한 모듈만 올려서 바로 실행될 수 있도록 한다.

요구할 때 가져오는게 아닌 미리 가져오는 것은 캐시(Cache) 라고 한다.  
캐시 히트가 되는 경우 상당한 성능 향상을 기대할 수 있지만 히트를 못하는 경우 리스크 때문에 요구 페이지 기법을 기본으로 사용한다.

### ⚙ <b>페이지 테이블 엔트리의 구조</b>
가상 메모리의 크기는 물리 메모리와 스왑 영역을 합친 것이다.
  
페이지가 스왑 영역에 있다는 경우는 두 가지로 나눌 수 있다.

- 요구 페이징으로 처음부터 물리 메모리로 올라가지 못한 경우
- 스압 아웃으로 쫓겨난 경우

페이지의 위치를 알 수있게 유효 비트를 사용해서 표시한다.
페이지 테이블 엔트리의 구성은 다음과 같다.

```
| 페이지 번호 | a | m | v | r | w | x | 프레임 번호 |
           ↳        플래그 비트      ↲ ↳ 주소 필드 ↲
   
a: access bit(= reference bit)
m: modified bit(= dirty bit)
v: valid bit(= present bit)
r: read bit    ⤵
w: write bit   (= rights bit)
x: excute bit  ⤴       
```

- 접근 비트: 메모리에 올라온 후 사용된 적이 있는지(= 참조 비트)
- 변경 비트: 메모리에 올라온 후 데이터 변경이 있었는지
- 유효 비트: 메모리에 존재하는지
- 읽기, 쓰기, 실행: 말 그대로 권한에 대한 비트(= 권한 비트)

### ⚙ <b>페이지 부재</b>
유효 비트가 1로 되어있어 실제 메모리 상에 페이지가 없다면 페이지 부재(Page Fault) 라고 한다.  
Page Fault 가 발생하면, 스왑 영역에서 물리 메모리로 데이터를 가져와야 한다.

[그림9-6] p.428

그림과 같이 빈 프레임이 없다면 메모리에서 가져와서 프레임에 할당하면 되지만 빈 프레임이 없을 경우 페이지 교체 알고리즘(Page Replacement Algorithm)
을 통해서 스왑 아웃이 될 대상 페이지를 선정하는데 이 떄 페이지를 대상 페이지(Victim Page) 라고 한다.

[그림9-7] p.429

위 그림은 프레임 하나를 스왑 아웃을 통해서 내보내고 새로운 데이터를 스왑인 하는 과정이다.

- Segmentation Fault: 프로세스가 할당 받은 영역 밖의 메모리를 참조하거나, 권한이 없는 곳을 접근할 때
- Page Fault: 물리 메모리에 참조하고자 하는 데이터가 없을 때

### ⚙ <b>지역성(Locality)</b>
스왑이 발생하는 경우 가능하면 앞으로 사용하지 않을 페이지를 쫓아내는 것이 당연히 좋다.  
그런 이유로 페이지를 쫓아내는 경우 페이지 교체 알고리즘은 지역성을 바탕으로 실행된다.

- 공간의 지역성(Spatial Locality): 현재 위치에서 가까운 데이터에 위치할 확률이 더 높다.
- 시간의 지역성(Temporal Locality): 가장 가까운 시간대에 접근한 데이터가 사용될 확률이 더 높다.
- 순차적 지역성(Sequential Locality): 프로그래밍은 처음에서 마지막 순서로 진행되는 경향이 있다는걸 의미한다.

지역성을 이용하는 가장 대표적인 장치로 캐시가 있으며, goto 문 사용을 지양하라는 의미도 지역성 때문이다.

****

## 📌 <b>페이지 교체 알고리즘</b>

### ⚙ <b>페이지 교체 알고리즘의 개요</b>
```
Page Fault -> 스왑 영역에서 메모리로 데이터 가져옴
```

이 상황에서 메모리가 가득 찼을 경우 어느 페이지를 교체할지 정하는 알고리즘으로 앞으로 사용할 가능성이 적은 페이지를 대상으로 선정하는 걸 목표로한다.

|종류|알고리즘|특징|
|:---:|:---:|:---:|
|간단한 알고리즘|무작위|무작위로 대상 페이지 선정|
|-|FIFO|가장 먼저 들어온 페이지 선정|
|이론적 알고리즘|Optimal|미래 접근 패턴을 보고 선정|
|최적 근접 알고리즘|LRU|시간적으로 멀리 떨어진 페이지 선정|
|-|LFU|사용 빈도가 적은 페이지 선정|
|-|NUR|최근에 사용한 적이 없는 페이지 선정|
|-|FIFO 변형|FIFO 알고리즘 변형|

### ⚙ <b>Random</b>
무작위 페이지 교체 알고리즘(Random Page Replacement Algorithm) 은 이름 그대로 스왑 영역으로 쫓아낼 대상 페이지를 특별한 로직 없이
무작위로 선정하기 떄문에 지역성에 대해서 전혀 고려되지 않은 알고리즘이다.

### ⚙ <b>FIFO(First In, First Out)</b>
선입 선출 알고리즘으로 가장 먼저 들어온 페이지를 쫓아내는 방식이기 때문에 선입선출 알고리즘인 큐(Queue)를 이용해서 구현한다.

[그림9-10] p.434

F -Page Fault, S - 메모리에 존재   
그림을 보면 처음으로 스왑되는 순간은 4번째로 'D' 를 참조했지만 메모리상에 올라와있지 않기 때문에 가장 먼저 들어온 'A'를 스왑 아웃 시킨다.
  
```
총 요구: 10번
Page Fault: 7번
```

해당 알고리즘은 시간적 지역성만 보면 오래된 알고리즘을 Victim 으로 선정하니 괜찮지만, 오래되었지만 자주 사용되는 페이지도 스왑 아웃 시키기 때문에 최적의
알고리즘이라고 볼 수 없다.   

시간과 상관없이 자주 쓰이는 페이지가 있는 케이스도 고려해야한다. 

### ⚙ <b>Optimal</b>
최적 페이지 교체 알고리즘으로 앞으로 사용되지 않을 페이지를 스왑 아웃 하는 알고리즘이다.  
설명에서 알 수 있듯이 미래에대한 정보를 알 수 있어야 가능한 알고리즘이기 때문에 구현이 불가능하다.
  
이론적으로 완벽한 알고리즘이라고 할 수 있다.

### ⚙ <b>LRU(Least Recently Used)</b>
최적 근접 알고리즘(Optimal Approximation Algorithm)중 하나로 최근 최소 사용 페이지 알고리즘이다.  
메모리에 올라온 후 가장 오랫동안 사용되지 않은 페이지를 Victim 으로 선정하는 알고리즘이다.
  
구현 방식에는 여러가지 방법이 있다.

#### 👉 페이지 접근 시간 기반 구현  
페이지에 시간을 기록하여 읽기, 쓰기, 실행 같은 페이지 접근이 가장 오래된 페이지를 Victim 으로 선정하여 스왑 대상으로 정하는 알고리즘이다.  
기록을 위한 추가적인 메모리 공간을 필요로 한다.
  
일반적으로 FIFO 보다는 우수하고 최적 보다는 조금 떨어진다.

#### 👉 카운터에 기반한 구현
페이지에 접근 횟수를 카운트 하여 구현한다.  
시간 기반과 마찬가지로 추가적으로 카운팅 할 수 있는 메모리 공간이 필요한데 예를 들어서 500번 접근 했음을 표시 하기 위해서는 9 bit 가 최소로 필요하며, 1000
번을 표현하기 10 bit 가 추가로 필요하다.
  
추가로 메모리를 요구한다는건 사용자가 사용할 수 있늠 메모리 공간이 더 적어진다는 뜻이다.

#### 👉 참조 비트 시프트 방식
Reference Shift Bit 방식을 사용한 구현법이다.  
말 그대로 비트를 시프트 연산을 통해서 옆으로 밀고, 가장 큰 수를 갖는 참조 비트는 가장 최근에 접근했다는 뜻이다.

```
[ 초기 ]
A | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |
B | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |
C | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |

[ A 접근 ]
A | 1 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |
B | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |
C | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |

[ B 접근 ]
A | 0 | 1 | 0 | 0 | 0 | 0 | 0 | 0 |
B | 1 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |
C | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |

[ A 접근 ]
A | 1 | 0 | 1 | 0 | 0 | 0 | 0 | 0 |
B | 0 | 1 | 0 | 0 | 0 | 0 | 0 | 0 |
C | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |
```
  
앞서 설명한 구현 방식들과 같이 추가로 필요한 1B 의 메모리를 요구하기 때문에 낭비되는 메모리 공간이 생긴다.

### ⚙ <b>LFU(Least Frequently Used)</b>
최소 빈도 사용 알고리즘으로 사용된 빈도수를 통해서 Victim 을 선정하는 알고리즘이다.
  
추가로 빈도 수 측정을 위한 메모리 공간을 필요로 한다는 것 말고는 특징 없다.

### ⚙ <b>NUR(Not Used Recently)</b>
불필요한 공간 나입를 해결한 알고리즘으로 최근 미사용 페이지 교체 알고리즘이다.

앞서 살펴본 PTE 의 참조 비트와 변경 비트를 이용한다.

- 참조: read/execute
- 변경: write/append

```
     접근 변경
초기: (0, 0)
접근: (1, 0)
변경: (0, 1)
둘다: (1, 1)
```

페이지 추방 우선 순위
- (0, 0): 페이지에 접근, 변경이 없었음
- (0, 1): 변경만
- (1, 0): 접근만
- (1, 1): 둘 다

모든 페이지의 비트 상태가 (1, 1)인 경우 (0, 0)으로 초기화 한다.
  
단 2 bit 만 필요하기 때문에 메모리 낭비가 없으며, 최적 알고리즘과 유사한 성능을 낼 수 있고, 구현도 쉽다. 

### ⚙ <b>Second Chance</b>
FIFO 의 변형 알고리즘이기 때문에 기본적으로 Queue 를 사용하여 구현한다.  
Page Fault 없이 페이지 접근을 하였다면 해당하는 페이지는 Queue 의 맨 뒤로 옮기는 방식이다.
  
자주 사용되는 페이지라면 선입선출 방식에서도 계속해서 Victim 선정에서 벗어날 수 있기 때문에 Second Chance 라고 불린다.
  
단점으로는 뒤로 이동해야하는 페이지가 Queue 의 중간에 위치한다면, 뒤로 이동하는 추가 비용과 큐를 유지하기 위한 비용이 들어간다.

### ⚙ <b>Clock</b>
Clock 알고리즘은 그냥 Queue 가 아니라 Circular Queue 를 사용하여 구현한다.  
  
포인터를 이용해서 Victim 페이지를 가르키며, 시작부터 끝까지 가면 다시 시작부터 시작하기 때문에 Clock 과 같은 모습을 보여서 이름이 지어졌다.  

동작 방식은 참조 비트를 이용하는데 포인터가 가르키는 페이지의 참조 비트가 0인경우 Victim 페이지로 선정하며, 1인 경우 참조 비트를 0으로 변경한 후
다음 페이지로 넘어간다.
  
참조 비트를 위한 단 1 bit 를 추가 메모리로 요구한다.

****

## 📌 <b>스레싱과 프레임 할당</b>

### ⚙ <b>스레싱</b>
### ⚙ <b>정적 할당</b>
### ⚙ <b>동적 할당</b>

****

## 📌 <b>프레임 관련 이슈</b>

### ⚙ <b>전역 교체와 지역 교체</b>
### ⚙ <b>페이지 테이블 크기</b>
### ⚙ <b>쓰기 시점 복사</b>
### ⚙ <b></b>