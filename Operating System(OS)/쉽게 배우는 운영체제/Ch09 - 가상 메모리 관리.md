# **Chapter09 - 가상 메모리 관리**

# **[ 📋 목차 ]**
- 요구 페이징
- 페이지 교체 알고리즘
- 스레싱과 프레임 할당
- 프레임 관련 이슈

****

# **[ 🗂️ 정리 ]**
## 📌 <b>요구 페이징(Demand Paging)</b>
프로세스가 필요로 하는 데이터를 요청할 때 메모리로 가져오는 방법이다.

### ⚙ <b>요구 페이징의 개요</b>
> 컴퓨터를 오랫동안 켜두었을 때 오랫동안 사용하지 않았지만 켜둔 프로세스와 좀비 프로세스들 때문에
> 느려지는 현상이 발생한다.

메모리 효율을 위해서 용량이 큰 프로세스를 실행할 때 프로세스를 구성하는 모든 모듈을 메모리에 올리지 않고, 필요할 때 메모리에서 불러온다.

- 메모리 효율성: 사용하지도 않는 데이터를 메모리에 올려둘 필요 없음
- 속도 향상: 필요한 모듈만 올려서 바로 실행될 수 있도록 한다.

요구할 때 가져오는게 아닌 미리 가져오는 것은 캐시(Cache) 라고 한다.  
캐시 히트가 되는 경우 상당한 성능 향상을 기대할 수 있지만 히트를 못하는 경우 리스크 때문에 요구 페이지 기법을 기본으로 사용한다.

### ⚙ <b>페이지 테이블 엔트리의 구조</b>
가상 메모리의 크기는 물리 메모리와 스왑 영역을 합친 것이다.
  
페이지가 스왑 영역에 있다는 경우는 두 가지로 나눌 수 있다.

- 요구 페이징으로 처음부터 물리 메모리로 올라가지 못한 경우
- 스압 아웃으로 쫓겨난 경우

페이지의 위치를 알 수있게 유효 비트를 사용해서 표시한다.
페이지 테이블 엔트리의 구성은 다음과 같다.

```
| 페이지 번호 | a | m | v | r | w | x | 프레임 번호 |
           ↳        플래그 비트      ↲ ↳ 주소 필드 ↲
   
a: access bit(= reference bit)
m: modified bit(= dirty bit)
v: valid bit(= present bit)
r: read bit    ⤵
w: write bit   (= rights bit)
x: excute bit  ⤴       
```

- 접근 비트: 메모리에 올라온 후 사용된 적이 있는지(= 참조 비트)
- 변경 비트: 메모리에 올라온 후 데이터 변경이 있었는지
- 유효 비트: 메모리에 존재하는지
- 읽기, 쓰기, 실행: 말 그대로 권한에 대한 비트(= 권한 비트)

### ⚙ <b>페이지 부재</b>
유효 비트가 1로 되어있어 실제 메모리 상에 페이지가 없다면 페이지 부재(Page Fault) 라고 한다.  
Page Fault 가 발생하면, 스왑 영역에서 물리 메모리로 데이터를 가져와야 한다.

[그림9-6] p.428

그림과 같이 빈 프레임이 없다면 메모리에서 가져와서 프레임에 할당하면 되지만 빈 프레임이 없을 경우 페이지 교체 알고리즘(Page Replacement Algorithm)
을 통해서 스왑 아웃이 될 대상 페이지를 선정하는데 이 떄 페이지를 대상 페이지(Victim Page) 라고 한다.

[그림9-7] p.429

위 그림은 프레임 하나를 스왑 아웃을 통해서 내보내고 새로운 데이터를 스왑인 하는 과정이다.

- Segmentation Fault: 프로세스가 할당 받은 영역 밖의 메모리를 참조하거나, 권한이 없는 곳을 접근할 때
- Page Fault: 물리 메모리에 참조하고자 하는 데이터가 없을 때

### ⚙ <b>지역성(Locality)</b>
스왑이 발생하는 경우 가능하면 앞으로 사용하지 않을 페이지를 쫓아내는 것이 당연히 좋다.  
그런 이유로 페이지를 쫓아내는 경우 페이지 교체 알고리즘은 지역성을 바탕으로 실행된다.

- 공간의 지역성(Spatial Locality): 현재 위치에서 가까운 데이터에 위치할 확률이 더 높다.
- 시간의 지역성(Temporal Locality): 가장 가까운 시간대에 접근한 데이터가 사용될 확률이 더 높다.
- 순차적 지역성(Sequential Locality): 프로그래밍은 처음에서 마지막 순서로 진행되는 경향이 있다는걸 의미한다.

지역성을 이용하는 가장 대표적인 장치로 캐시가 있으며, goto 문 사용을 지양하라는 의미도 지역성 때문이다.

****

## 📌 <b>페이지 교체 알고리즘</b>

### ⚙ <b>페이지 교체 알고리즘의 개요</b>
```
Page Fault -> 스왑 영역에서 메모리로 데이터 가져옴
```

이 상황에서 메모리가 가득 찼을 경우 어느 페이지를 교체할지 정하는 알고리즘으로 앞으로 사용할 가능성이 적은 페이지를 대상으로 선정하는 걸 목표로한다.

|종류|알고리즘|특징|
|:---:|:---:|:---:|
|간단한 알고리즘|무작위|무작위로 대상 페이지 선정|
|-|FIFO|가장 먼저 들어온 페이지 선정|
|이론적 알고리즘|Optimal|미래 접근 패턴을 보고 선정|
|최적 근접 알고리즘|LRU|시간적으로 멀리 떨어진 페이지 선정|
|-|LFU|사용 빈도가 적은 페이지 선정|
|-|NUR|최근에 사용한 적이 없는 페이지 선정|
|-|FIFO 변형|FIFO 알고리즘 변형|

### ⚙ <b>Random</b>
무작위 페이지 교체 알고리즘(Random Page Replacement Algorithm) 은 이름 그대로 스왑 영역으로 쫓아낼 대상 페이지를 특별한 로직 없이
무작위로 선정하기 떄문에 지역성에 대해서 전혀 고려되지 않은 알고리즘이다.

### ⚙ <b>FIFO(First In, First Out)</b>
선입 선출 알고리즘으로 가장 먼저 들어온 페이지를 쫓아내는 방식이기 때문에 선입선출 알고리즘인 큐(Queue)를 이용해서 구현한다.

[그림9-10] p.434

F -Page Fault, S - 메모리에 존재   
그림을 보면 처음으로 스왑되는 순간은 4번째로 'D' 를 참조했지만 메모리상에 올라와있지 않기 때문에 가장 먼저 들어온 'A'를 스왑 아웃 시킨다.
  
```
총 요구: 10번
Page Fault: 7번
```

해당 알고리즘은 시간적 지역성만 보면 오래된 알고리즘을 Victim 으로 선정하니 괜찮지만, 오래되었지만 자주 사용되는 페이지도 스왑 아웃 시키기 때문에 최적의
알고리즘이라고 볼 수 없다.   

시간과 상관없이 자주 쓰이는 페이지가 있는 케이스도 고려해야한다. 

### ⚙ <b>Optimal</b>
최적 페이지 교체 알고리즘으로 앞으로 사용되지 않을 페이지를 스왑 아웃 하는 알고리즘이다.  
설명에서 알 수 있듯이 미래에대한 정보를 알 수 있어야 가능한 알고리즘이기 때문에 구현이 불가능하다.
  
이론적으로 완벽한 알고리즘이라고 할 수 있다.

### ⚙ <b>LRU(Least Recently Used)</b>
최적 근접 알고리즘(Optimal Approximation Algorithm)중 하나로 최근 최소 사용 페이지 알고리즘이다.  
메모리에 올라온 후 가장 오랫동안 사용되지 않은 페이지를 Victim 으로 선정하는 알고리즘이다.
  
구현 방식에는 여러가지 방법이 있다.

#### 👉 페이지 접근 시간 기반 구현  
페이지에 시간을 기록하여 읽기, 쓰기, 실행 같은 페이지 접근이 가장 오래된 페이지를 Victim 으로 선정하여 스왑 대상으로 정하는 알고리즘이다.  
기록을 위한 추가적인 메모리 공간을 필요로 한다.
  
일반적으로 FIFO 보다는 우수하고 최적 보다는 조금 떨어진다.

#### 👉 카운터에 기반한 구현
페이지에 접근 횟수를 카운트 하여 구현한다.  
시간 기반과 마찬가지로 추가적으로 카운팅 할 수 있는 메모리 공간이 필요한데 예를 들어서 500번 접근 했음을 표시 하기 위해서는 9 bit 가 최소로 필요하며, 1000
번을 표현하기 10 bit 가 추가로 필요하다.
  
추가로 메모리를 요구한다는건 사용자가 사용할 수 있늠 메모리 공간이 더 적어진다는 뜻이다.

#### 👉 참조 비트 시프트 방식
Reference Shift Bit 방식을 사용한 구현법이다.  
말 그대로 비트를 시프트 연산을 통해서 옆으로 밀고, 가장 큰 수를 갖는 참조 비트는 가장 최근에 접근했다는 뜻이다.

```
[ 초기 ]
A | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |
B | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |
C | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |

[ A 접근 ]
A | 1 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |
B | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |
C | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |

[ B 접근 ]
A | 0 | 1 | 0 | 0 | 0 | 0 | 0 | 0 |
B | 1 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |
C | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |

[ A 접근 ]
A | 1 | 0 | 1 | 0 | 0 | 0 | 0 | 0 |
B | 0 | 1 | 0 | 0 | 0 | 0 | 0 | 0 |
C | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |
```
  
앞서 설명한 구현 방식들과 같이 추가로 필요한 1B 의 메모리를 요구하기 때문에 낭비되는 메모리 공간이 생긴다.

### ⚙ <b>LFU(Least Frequently Used)</b>
최소 빈도 사용 알고리즘으로 사용된 빈도수를 통해서 Victim 을 선정하는 알고리즘이다.
  
추가로 빈도 수 측정을 위한 메모리 공간을 필요로 한다는 것 말고는 특징 없다.

### ⚙ <b>NUR(Not Used Recently)</b>
불필요한 공간 나입를 해결한 알고리즘으로 최근 미사용 페이지 교체 알고리즘이다.

앞서 살펴본 PTE 의 참조 비트와 변경 비트를 이용한다.

- 참조: read/execute
- 변경: write/append

```
     접근 변경
초기: (0, 0)
접근: (1, 0)
변경: (0, 1)
둘다: (1, 1)
```

페이지 추방 우선 순위
- (0, 0): 페이지에 접근, 변경이 없었음
- (0, 1): 변경만
- (1, 0): 접근만
- (1, 1): 둘 다

모든 페이지의 비트 상태가 (1, 1)인 경우 (0, 0)으로 초기화 한다.
  
단 2 bit 만 필요하기 때문에 메모리 낭비가 없으며, 최적 알고리즘과 유사한 성능을 낼 수 있고, 구현도 쉽다. 

### ⚙ <b>Second Chance</b>
FIFO 의 변형 알고리즘이기 때문에 기본적으로 Queue 를 사용하여 구현한다.  
Page Fault 없이 페이지 접근을 하였다면 해당하는 페이지는 Queue 의 맨 뒤로 옮기는 방식이다.
  
자주 사용되는 페이지라면 선입선출 방식에서도 계속해서 Victim 선정에서 벗어날 수 있기 때문에 Second Chance 라고 불린다.
  
단점으로는 뒤로 이동해야하는 페이지가 Queue 의 중간에 위치한다면, 뒤로 이동하는 추가 비용과 큐를 유지하기 위한 비용이 들어간다.

### ⚙ <b>Clock</b>
Clock 알고리즘은 그냥 Queue 가 아니라 Circular Queue 를 사용하여 구현한다.  
  
포인터를 이용해서 Victim 페이지를 가르키며, 시작부터 끝까지 가면 다시 시작부터 시작하기 때문에 Clock 과 같은 모습을 보여서 이름이 지어졌다.  

동작 방식은 참조 비트를 이용하는데 포인터가 가르키는 페이지의 참조 비트가 0인경우 Victim 페이지로 선정하며, 1인 경우 참조 비트를 0으로 변경한 후
다음 페이지로 넘어간다.
  
참조 비트를 위한 단 1 bit 를 추가 메모리로 요구한다.

****

## 📌 <b>스레싱과 프레임 할당</b>

### ⚙ <b>스레싱(Threshing)</b>
하드웨어 입출력이 너무 만아져서 잦은 스왑 인, 아웃 발생으로 작업이 멈춘 것 같은 현상을 '스레싱' 이라고 한다.

스레싱은 멀티프로그램과 밀접한 연관이 있는게 동시에 실행하는 프로르갦 수가 많아지면 발생한다.  
프로그매 수를 멀티프로그맹 정도(Degree Of Multiprogramming) 이라고 한다.
  
스왑 영역으로 페이지를 인, 아웃 하는 작업이 빈번해지면 CPU 가 작업하는 스왑 작업이 더 빈번해져서 CPU 가 작업을 할 수 없는 상태에 이르는데, 이를
스레싱 발생 지점(Threshing Point) 라고 한다.

### ⚙ <b>정적 할당(Static Allocation)</b>
프로세스 실행 초기에 프레임을 나누어준 후 크기를 고정하는 방법

#### 👉 균등 할당(Equal Allocation)

가용 프레임의 개수를 프로세스의 개수만큼 나누어서 균등하게 할당하는 방식이다.

```
가용 프레임: 9개
프로세스A 요구: 6개
프로세스B 요구: 9개
프로세스C 요구: 3개

모든 프레임은 동등하게 3개의 프레임을 할당 받는다.
```

어떤 프로세스는 적당한 프레임 개수를 받지만, 어떤 페이지는 한참 모자른 프레임을 할당받게되고, 이렇게 많이 모자란 프레임을 갖는 프로세스는 빈번한
Page Fault 를 발생시킨다.
  
또한 크기가 작은 프로세스도 필요한 것 이상으로 할당을 받을 가능성이 있고, 이는 메모리 낭비를 초래한다.

#### 👉 비례 할당(Proportional Allocation)
프로세스 크기에 비례하여 프레임을 할당하는 방식

```
가용 프레임: 12개
프로세스A 요구: 6개
프로세스B 요구: 9개
프로세스C 요구: 3개
전체 프로세스 요구: 18개

A: 6 * 12 / 18(4개)
B: 9 * 12 / 18(2개)
C: 3 * 12 / 18 (6개)
```

고정 할당보다는 더 나아진 모습이다.
  
- 고정 할당의 문제점
    - 프로세스가 실행중 필요로하는 유동적인 프레임은 고려하지 못한다.
    > 동영상 플레이어 프로세스는 작지만 실행되는 동영상이 크다.
    - 사용하지 않을 메모리도 초기에 미리 확보해 공간을 낭비한다.

### ⚙ <b>동적 할당(Dynamic Allocation)</b>
프로세스가 실행중일 때 요구하는 프레임도 반영하기 위한 방법  

#### 👉 작업집합 모델(Working Set Model)
지역성 이론 바탕으로 최근에 참조된 프레임이 또 참조될 가능성이 높음을 가정하고 출발하는 방법으로 최근 일정 시간 참조된 페이지들을 집합으로 만들고, 이 집합의
페이지들을 물리 메모리에 유지해 프로세스 실행을 돕는다.
  
작업집합 크기는 Working Set Size 라고 하며, 작어빚ㅂ합에 포함되는 페이지의 범위는 작업집함 윈도우 Working Set Window, WSW 라고 한다.

[그림9-26] p.452

만약 작업집합 크기를 5 로 설정했다면, 페이지에 5번 접근 후 작업 집합을 갱신 한다는 의미다.
만약 작업집합 윈도우에 작업집합 크기보다 많은 페이지가 있다면, 시작 작업에서 가까운 순서대로 삽입한다.
  
작업 집합 윈도우의 크기기를 너무 크게 잡는다면, 필요 없는 페이지가 메모리에 남아서 다른 프로세스에 영향을 미치고, 너무 작게 잡는다면 잦은 스왑이 벌어진다.

#### 👉 페이지 부재 빈도(Page Fault Frequency)
Page Fault 비율을 계산하는 방식으로, 비율의 상한선과 하한선을 설정해서 상한선을 초과하게 되면, 할당한 프레임이 적다는 뜻으로 프레임을 추가하고, 하한선을
초과하면 메모리가 낭비된다는 의미로 프레임을 회수한다.
  
프로세스가 처음 시작될 때에는 Page Fault 비율을 예상하기 힘들어 프로세스를 실행 하면서 추가하거나 회수하여 조정한다.

****

## 📌 <b>프레임 관련 이슈</b>

### ⚙ <b>전역 교체와 지역 교체</b>

- 전역 교체(global Replacement): 전체 프레임 대상으로 교체 알고리즘 적용
  - 프로세스 A, B, C 가 있다면 스왑은 A, B, C 가 할당받은 모든 프레임 내에서 이루어진다.
- 지역 교체(local Replacement): 현재 실행중인 프로세스의 프레임을 대상으로 교체 알고리즘 적용
  - 프로세스 A, B, C 가 있다면 스왑은 A 가 할당받은 프레임 내에서만 이루어진다.
    
전역의 단점은 교체하게 된다면 다른 프로세스의 프레임을 빼앗기 때문에 할당받은 프레임이 부족해진 프로세스가 스레싱을 발생 시킬 수 있다.
  
지역의 단점은 페이지가 자주 스왑되어 시스템 효율이 떨어질 수 있따.

### ⚙ <b>페이지 테이블 크기</b>
운영체제마다 다양한 페이지 크기를 갖는다.

```
⚙︎ 32 bit CPU
︎︎⚙ Page Size: 4KB (2^12)

※ 4GB / 4KB = 1,048,576B로 가상 주소를 페이지 테이블로 나타내기 위한 1048576개의 행과 
각 행을 표현할 주소 공간 20 bit 가 필요하다.
(4KB 페이지가 1048576개 있고, 페이지 테이블을 주소로 표현하기 위해서 최소 20 bit 가 필요하다)
(왜 20 bit? => 1048576 를 표현하기 위해서)
```

위 계산대로라면, 1048576 * 20 bit = 2.26MB 로, 페이지 테이블 크기가 나온다.  
  
만약 여기서 페이지 크기를 521B(2^9) 사이즈로 줄인다면 24.11MB 의 페이지 테이블 크기가 나오는데 약 9.2 배 큰 수치이다.
  
프로세스마다 페이지 테이블이 필요하니 단순히 프로세스 100개라고 생각하면 0.262GB와 2.411GB 가 된다.  
하지만 무작정 페이지 테이블의 크기를 줄이기 위해 페이지의 크기를 키우면 내부 단편화의 발생으로 낭비되는 메모리가 생기기 때문에 적절한 조정이 필요하다.

### ⚙ <b>쓰기 시점 복사</b>
Copy On Write 는 프로세스를 fork 할 때 프로세스끼리 공유하지 않는 영역 즉 데이터 영역을 언제 확보할까에서 시작한 방법이다.
  
프로세스A 를 fork 하면 PT 복하사여 쉽게 프로세스를 복사하여 프로세스B 를 만들 수 있다.  
하지만 프로세스A 가 사용하던 데이터 영역도 똑같이 사용하고 있는데, 무작정 프로세스B 에게도 할당할 수 없기 때문에(프로세스B 가 별다른 작업 없이도
끌 수 있기 때문에) 바보 데이터도 복사하는게 아닌, 데이터의 변화가 감지되는 시점에 물리 메모리에 복사하는 방법이다. 