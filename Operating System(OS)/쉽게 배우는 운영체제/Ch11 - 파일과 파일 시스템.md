# **Chapter10 - 입출력 시스템과 저장장치**

# **[ 📋 목차 ]**
- 파일과 파일 시스템
- 디렉토리의 구조
- 디스크 파일 할당

****

# **[ 🗂️ 정리 ]**
## 📌 <b>파일과 파일 시스템</b>

### ⚙ <b>파일 시스템의 개요</b>
시용자가 저장장치 내부를 함부로 사용하면 안되기 때문에 OS 에서 직접적인 접근을 막으며, 파일 관리 시스템을 두어 저장 장치의 관리를 하도록 한다.

가상 메모리와 같이 파일 테이블을 사용하여 파일의 생성, 수정, 삭제 등을 수행한다.  
파일에 대한 권한에 따라 다양한 접근 방법을 제공한다.  
파일에 접근하기 위해서는 파일 접근 권한을 얻어야 하는데 이를 파일 디스크립터(File Descriptor) 라고 한다.
  
파일 시스템은 아래와 같은 기능들을 제공한다.

|기능|설명|
|:---:|:--------:|
|파일 구성|사용자 요구에 따라 파일과 디렉토리를 만든다.|
|파일 관리|파일 생성, 수정, 삭제 등의 관리를 하고, 수시로 조각 모음을 하여 사용자가 파일에 빨리 접근할 수 있도록 한다.|
|접근 권한 관리|다른 사용자로부터 파일을 보호하기 위해 접근 권한을 관리한다.|
|접근 방법 제공|파일을 읽고 쓰고 실행할 수 있도록 사용자에게 접근 방법을 제공한다.|
|무결성 보장|파일의 내용이 손상되지 않도록 무결성을 보장한다.|
|백업과 복구|사고로부터 파일을 보호하기 위해 백업과 복구 작업을 한다.|
|암호화|파일을 암호화하여 악의적인 접근으로부터 파일을 보호한다.|

메모리는 바이트 단위로 저장되고, OS와 저장장치 간에는 블록 단위로 저장되며, 디스크의 물리적인 구조상 가장 작은 단위는 섹터로 구분된다.  
메모리에 비해서 하드웨어가 많이 크기 때문에 주소를 하나씩 부여하는건 불가능하기 때문에 섹터들을 묶어서 하나의 블록으로 만들고, 하나의 블록에 주소 하나를 할당한다.
  
블록의 크기를 설정할 수 있지만 너무 작으면 파일 입출력 속도가 느려지고, 너무 크면 내부 단편화가 일어날 수 있다.

[그림11-3] 파일 테이블과 블록 (p.529)

### ⚙ <b>파일 분류와 확장자</b>
모든 파일은 0과 1 비트 패턴(Bit Pattern) 으로 이루어지며, OS 입장으로는 실행 파일과, 데이터 파일로 나뉜다.

- 실행 파일: 운영채재거 메모리로 가져와 CPU 를 이용하는 작업을 하는 파일. (사용자 요청으로 프로세스가 된 파일)
- 데이터 파일:필요한 데이터를 모아놓은 파일로 스스로 프로세스는 될 수 없다.

PNG, JPG 등 다양한 데이터 파일이 존재하는데 이런 파일들을 구분하기 위해서 파일에는 헤더가 달려있다.  
헤더에는 파일의 이름, 버전, 크기, 만든 날짜, 접근 권한 등의 정보가 있고, 각 파일은 고유한 헤더를 갖는다.

### ⚙ <b>파일 이름과 연결 프로그램</b>
파일명은 파일명.확장자 형태로 구성된다.

- 초칭가 관습으로 확장자는 3개 이하가 대부분이다.
- 마지막 마침표(.) 가 확장자로 인식된다.
- 파일명은 경로를 포함해서 최대 255자 까지 가능하다.

실행 파일은 바로 실행되는 반면에 데이터 파일은 해당 파일을 사용하는 응용 프로그램이 실행된다.  
여기서 말하는 응용 프로그램은 데이터 파일이 실행되면 OS 가 해당 응용 프로그램을 실행해 주는거지 데이터 파일이 실행 파일이 되는건 아니다.

### ⚙ <b>파일 속성</b>
파일의 속성은 파일의 헤더에서, 헤더는 파일 테이블에서 관리된다.

- name: 확장자를 포함한 이름
- type: 실행, 동영상, 사진, 음악 파일들과 같이 확장자로 구분된다.
- size: 파일의 용량
- time: 접근, 생성, 변경, 오픈 시간 등으로 세분화
- location: 이름과 확장자가 같은 파일은 한 디렉토리에 존재할 수 없으며 서로 다른 디렉토리에는 존재할 수 있는데, 이를 확인하는게 파일의 위치 정보 이다.
- accessibility: 읽기, 쓰기, 숨김 등이 있고, 유닉스는 추가로 소유자, 그룹, 제삼자에 따라 다르다.
- owner: 윈도우는 없지만 유닉스는 파일의 소유자가 명확하게 구분된다.

OS 가 관리하는 파일 헤더 외에 데이터 파일은 필요한 파일 속성을 고유 헤더에 기록한다.   
예를 들어 사진을 찍었다면 사진의 기종이 무엇인지 같은 속성이다.

- 파일 헤더: 파일 테이블에서 관리하는 일반적인 내용이 담기고, 파일이 몇 번째 저장장치 블록에 저장되어 있는지 등의 정보이다.
- 고유 헤더: 응용 프로그램이 필요로 하는 속성을 저장하는 헤더이다.

파일을 삭제하면 (빠른 포맷) 파일 테이블에서 지워져 파일 헤더는 사라지지만 실제 데이터를 지운게 아니기 때문에 저장장치에 고유 헤더가 남아 
고유 헤더를 통해서 파일을 복구할 수 있다.

### ⚙ <b>파일 작업의 유형</b>
파일에 대한 작업을 파일 연산(File Operation) 이라고 한다.   
파일 자체를 변경하는 작업과, 내용을 변경하는 작업으로 나뉜다.
  
[ 파일 자체를 변경하는 작업 ]

- open, close: 연결 프로그램을 실행한 후 데이터 파일을 가져온다. / 닫는다.
- create: 새로운 파일을 만든다.
- remove, copy, rename: 지정된 디렉토리의 위치를 변경(휴지통으로 이동시 삭제) / 같은 파일을 하나 더 만듦 / 파일 이름 변경
- list: 디렉토리에 있는 파일의 이름을 속성들과 함께 보여준다.
- search: 여러 디렉토리에서 파일을 찾는다.

[ 파일 내용을 변경하는 작업 ]
프로세스 입장에서 수행

- open() / create(): 파일에 대한 정당한 권한을 얻는다. (File Descriptor)
- read() / write(): 읽거나 쓰는 작업
- update() / insert() / delete() : 이름 그대로의 작업 (read/write 로 이 함수들을 구현 가능하다.)

### ⚙ <b>파일 구조</b>

#### 👉 순차 파일 구조(Sequential File Structure)
1번 부터 10번까지 있다면 앞으로(Forward) 혹은 뒤로(Backward) 이동하면서 원하는 위치로 가서 데이터를 읽는 방법이다.  

먼저 open() / create() 로 권한을 얻으면, File Descriptor 의 맨 처음 위치는 파일의 맨 앞이다.  
해당 위치에서 read() / write() 작업을 하게 된다면, FD 가 앞으로 전진하고, 특정 위치로 움직이기 위해서 lseek() 명령어를 사용한다.

- 장점
    - 모든 데이터가 순차적으로 기록되 공간 낭비가 없다.
    - 구조가 단순해 다른 저장장치에도 적용 가능
    - 순서대로 데이터를 읽거나 저장할 때 매우 빠름
- 단점
    - 파일에 새로운 데이터를 삽입, 삭제할 때 시간이 많이 걸린다.
        - 중간에 데이터 삽입 시 그 지점 뒤의 데이터를 뒤로 밀어 공간을 만들어야 한다.
        - 중간에 데이터 삭제 시 뒤의 데이터를 앞으로 당겨야 한다.
    - 특정 데이터를 찾기 위해서 순차적으로 움직여야해서 데이터 검색이 힘들다.
    
데이터 변경이 잦거나 검색이 필요한 경우 적절하지 않은 모델이다.

#### 👉 인덱스 파일 구조(Index File Structure)
인덱스 테이블을 추가하여 순차 접근과 직접 접근이 가능하다.  
각 인덱스는 파일의 블록들의 시작 위치를 갖고 있어 두 방식이 가능한 것이다.

[그림11-11] 인덱스 파일 구조 (p.539)

#### 👉 직접 파일 구조(Direct File Structure)
해시 함수를 이용해서 물리적인 주소로 변환하여 매핑하는 방식

## 📌 <b>디렉토리의 구조</b>

## 📌 <b>디스크 파일 할당</b>