# **Chapter03 - 영속성 관리**

# **[ 📋 목차 ]**
- 엔티티 매니저 팩토리와 엔티티 매니저
- 영속성 컨텍스트
- 엔티티의 생명주기
- 영속성 컨텍스트의 특징
- 플러시
- 준영속
- 정리

****

# **[ 🗂️ 정리 ]**
들어가기 앞서서 gradle을 이용해서 책의 내용을 전부 따라하지 않는 이유는 인프런 강의를 보면서 이미 1회독 했기 때문이다.

## 📌 <b>엔티티 매니저 팩토리와 엔티티 매니저</b>
엔티티 매니저라 하면 개발자의 입장에서는 엔티티를 저장하는 가상의 데이터베이스라고 생각하면 된다.  
엔티티 매니저 생성은 코스트가 많이 들어간다.

```java
// 나는 gradle과 application.properties 를 이용해서 만들지는 않음...
EntityManagerFactory emf = Persistence.createEntityManagerFactory("엔티티 유닛명");    // 팩토리 생성
EntityManager em = emf.createEntityManager();    // 엔티티 매니저 생성
```

엔티티 매니저는 보통 트랜잭션을 시작할 때 커넥션 풀에서 커넥션을 얻어온다.    
커넥션 풀은 엔티티 팩토리를 생성하면서 만든다.
  
※ 엔티티 매니저 팩토리은 여러개의 스레드가 동시 접근해도 무방하지만 엔티티 매니저 끼리는 여러 스레드가 동시 접근하면 동시성 문제가 발생한다.

**** 

## 📌 <b>영속성 컨텍스트란?</b>

영속성 컨텍스트(Persistence Context)는 '엔티리를 영구 저장하는 환경' 이라는 뜻이다.

```java
// 엔티티 매니저를 사용해서 해당 엔티티를 영속성 컨텍스트에 저장
em.persist(엔티티);
```

****

## 📌 <b>엔티티의 생명주기</b>
엔티티는 총 4가지 상태가 존재한다.

- 비영속(new/transient): 영속성 컨텍스트와 관계가 없는 상태
- 영속(managed): 영속성 컨텍스트에 저장된 상태
- 준영속(detached): 영속성 컨텍스트에 저장되었다가 분리된 상태
- 삭제(removed): 삭제된 상태

[그림 3.2] 93 page

### ⚙︎ <b>비영속</b>
엔티티 객체는 생성 했으나 순수한 객체 상태로 영속성 컨텍스트 혹은 데이터베이스와는 관련이 없는 상태

```java
// 그냥 자바 객체
엔티티 이름 = new 엔티티()
엔티티.set속성(attr1);
```

### ⚙︎ <b>영속</b>
엔티티를 엔티티 매니저를 통해서 영속성 컨텍스트에 저장한 상태로 엔티티 컨텍스트에 의해서 관리되는 엔티티의 상태이다.

```java
em.persit(엔티티명);
```

### ⚙︎ <b>준영속</b>
영속성 컨텍스트가 관리하다가 관리를 하지 않게 되면 준영속 상태라고 한다.

```java
// 영속성 컨텍스트에서 엔티티를 분리한다.
em.detach(엔티티명);
// 엔티티 매니저를 닫고 모든 자원을 해제한다.
em.close();
// 영속성 컨텍스트를 완전히 비운다. (비우고 난 뒤에는 지연 로딩이나 변경 감지는 없다.)
em.clear();
```

### ⚙︎ <b>삭제</b>
엔티티를 영속성 컨텍스트와 데이터베이스에서 삭제한다.

```java
em.remove(엔티티명);
```

****

## 📌 <b>영속성 컨텍스트의 특징</b>

- 영속성 컨텍스트와 식별자 값
  - 영속 상태는 식별자 값이 반드시 있어야 한다.(@Id)
- 영속성 컨텍스트와 데이터베이스 저장
  - 트랜잭션이 커밋되는 순간 영속성 컨텍스트에 새로 저장된 엔티티를 데이터베이스에 반영하고 이 과정을 '플러시(Flush)' 라고 한다.
- 영속성 컨텍스트가 엔티티를 관리하며 생기는 장점
  - 1차 캐시
  - 동일성 보장
  - 지연 로딩
  - 변경 감지
  - 쓰기 지연

### ⚙︎ <b>엔티티 조회</b>
영속성 컨텍스트는 내부에 캐시를 가지고 있는데 '1차 캐시' 라고 한다.  
영속성 컨텍스트 내부 엔티티가 저장되는 공간이고 @Id를 '키(key)' 로 사용하고 '값(value)' 는 엔티티이다.  
여기서 말하는 키는 데이터베이스에서 기본 키(Primary Key) 로 사용되고 있는 컬럼이다.

```java
public <T> T find(Class<T> entityClass, Object primaryKey);
```

캐시가 있기 때문에 조회를 하게 된다면 캐시를 먼저 뒤지고, 그 다음 데이터베이스에서 조회를 한다.

[그림 3.6] 97 page

1차 캐시에 없다면 엔티티 매니저는 데이터베이스를 조회해서 엔티티를 생성하고, 1차 캐시에 저장한 후 영속 상태인 엔티티를 반환한다.

[그림 3.7] 98 page

또한 key, value 형식으코 캐시에 매핑되어 있기 때문에 같은 식별자를 갖는 엔티티 인스턴스 동일성(==) 비교를 해도 참(true) 결과를 갖는다.

※ JPA는 'REPEATABLE READ' 격리 수준을 어플리케이션 레벨에서 제공한다.

### ⚙︎ <b>엔티티 등록</b>
엔티티 매니저는 트랜잭션 커밋을 실행하기전 까지는 데이터베이스에 엔티티를 저장하지 않는다.

```java
EntityTransaction transaction = em.getTransaction();

transaction.begin();   // 트랜잭션 시작
em.persist(엔티티명);    // DB에 저장하지 않음
transactioon.commit(); // DB에 저장
```

내부의 쿼리 저장소에 쿼리를 모았다가 커밋되는 시점에 데이터베이스로 보내고 이를 '<b>쓰기 지연(Transactional write-behind)</b>' 라고 한다.

[그림 3.9] 100 page

커밋을 하지 않으면 영속성 컨텍스트 내부의 저장소에 모아둔다.

쓰기 지연이 가능한 이유는 뭘까?

```java
transaction.begin();

em.persist(엔티티명A);
em.persist(엔티티명B);
em.persist(엔티티명C);

transactioon.commit(); 
```

persist가 실행될 때 마다 데이터베이스에 저장한다고 가정하면 A, B가 저장에 성공했더라도 C가 저장에 실패하면 롤백이 일어난다.  
그럼 JPA와 같이 모아서 실행한다면 결과가 다를까? 아니다 결과는 똑같다.  
매번 데이터베이스에 붙는 비용을 생각하면 쓰기 지연이 성능 항샹에 더 이점을 보인다.

### ⚙︎ <b>엔티티 수정</b>
SQL을 사용해서 개발을 한다고 하면 수정이 필요한 경우 어떨까?

```SQL
UPDATE MEMBER
   SET AGE = ?
 WHERE ID = ?
```

추가 사항이 생겨서 등급도 같이 변한다면?

```SQL
UPDATE MEMBER
   SET AGE = ?
     , GRADE = ?
 WHERE ID = ?
```

추가 사항이 생겨서 이름도 같이 변한다면?

```SQL
UPDATE MEMBER
   SET AGE = ?
     , GRADE = ?
     , NAME = ?
 WHERE ID = ?
```

****

## 📌 <b>플러시</b>

****

## 📌 <b>준영속</b>

****

## 📌 <b>정리</b>
