# **Chapter03 - 영속성 관리**

# **[ 📋 목차 ]**
- 엔티티 매니저 팩토리와 엔티티 매니저
- 영속성 컨텍스트
- 엔티티의 생명주기
- 영속성 컨텍스트의 특징
- 플러시
- 준영속
- 정리

****

# **[ 🗂️ 정리 ]**
들어가기 앞서서 gradle을 이용해서 책의 내용을 전부 따라하지 않는 이유는 인프런 강의를 보면서 이미 1회독 했기 때문이다.

## 📌 <b>엔티티 매니저 팩토리와 엔티티 매니저</b>
엔티티 매니저라 하면 개발자의 입장에서는 엔티티를 저장하는 가상의 데이터베이스라고 생각하면 된다.  
엔티티 매니저 생성은 코스트가 많이 들어간다.

```java
// 나는 gradle과 application.properties 를 이용해서 만들지는 않음...
EntityManagerFactory emf = Persistence.createEntityManagerFactory("엔티티 유닛명");    // 팩토리 생성
EntityManager em = emf.createEntityManager();    // 엔티티 매니저 생성
```

엔티티 매니저는 보통 트랜잭션을 시작할 때 커넥션 풀에서 커넥션을 얻어온다.    
커넥션 풀은 엔티티 팩토리를 생성하면서 만든다.
  
※ 엔티티 매니저 팩토리은 여러개의 스레드가 동시 접근해도 무방하지만 엔티티 매니저 끼리는 여러 스레드가 동시 접근하면 동시성 문제가 발생한다.

**** 

## 📌 <b>영속성 컨텍스트란?</b>

영속성 컨텍스트(Persistence Context)는 '엔티리를 영구 저장하는 환경' 이라는 뜻이다.

```java
// 엔티티 매니저를 사용해서 해당 엔티티를 영속성 컨텍스트에 저장
em.persist(엔티티);
```

****

## 📌 <b>엔티티의 생명주기</b>
엔티티는 총 4가지 상태가 존재한다.

- 비영속(new/transient): 영속성 컨텍스트와 관계가 없는 상태
- 영속(managed): 영속성 컨텍스트에 저장된 상태
- 준영속(detached): 영속성 컨텍스트에 저장되었다가 분리된 상태
- 삭제(removed): 삭제된 상태

![KakaoTalk_Photo_2024-03-20-22-55-17 001jpeg](https://github.com/nashs789/Book-Study/assets/59809278/0d731ce5-9c0d-4002-8e79-058391f35871)


### ⚙︎ <b>비영속</b>
엔티티 객체는 생성 했으나 순수한 객체 상태로 영속성 컨텍스트 혹은 데이터베이스와는 관련이 없는 상태

```java
// 그냥 자바 객체
엔티티 이름 = new 엔티티()
엔티티.set속성(attr1);
```

### ⚙︎ <b>영속</b>
엔티티를 엔티티 매니저를 통해서 영속성 컨텍스트에 저장한 상태로 엔티티 컨텍스트에 의해서 관리되는 엔티티의 상태이다.

```java
em.persit(엔티티명);
```

### ⚙︎ <b>준영속</b>
영속성 컨텍스트가 관리하다가 관리를 하지 않게 되면 준영속 상태라고 한다.

```java
// 영속성 컨텍스트에서 엔티티를 분리한다.
em.detach(엔티티명);
// 엔티티 매니저를 닫고 모든 자원을 해제한다.
em.close();
// 영속성 컨텍스트를 완전히 비운다. (비우고 난 뒤에는 지연 로딩이나 변경 감지는 없다.)
em.clear();
```

### ⚙︎ <b>삭제</b>
엔티티를 영속성 컨텍스트와 데이터베이스에서 삭제한다.

```java
em.remove(엔티티명);
```

****

## 📌 <b>영속성 컨텍스트의 특징</b>

- 영속성 컨텍스트와 식별자 값
  - 영속 상태는 식별자 값이 반드시 있어야 한다.(@Id)
- 영속성 컨텍스트와 데이터베이스 저장
  - 트랜잭션이 커밋되는 순간 영속성 컨텍스트에 새로 저장된 엔티티를 데이터베이스에 반영하고 이 과정을 '플러시(Flush)' 라고 한다.
- 영속성 컨텍스트가 엔티티를 관리하며 생기는 장점
  - 1차 캐시
  - 동일성 보장
  - 지연 로딩
  - 변경 감지
  - 쓰기 지연

### ⚙︎ <b>엔티티 조회</b>
영속성 컨텍스트는 내부에 캐시를 가지고 있는데 '1차 캐시' 라고 한다.  
영속성 컨텍스트 내부 엔티티가 저장되는 공간이고 @Id를 '키(key)' 로 사용하고 '값(value)' 는 엔티티이다.  
여기서 말하는 키는 데이터베이스에서 기본 키(Primary Key) 로 사용되고 있는 컬럼이다.

```java
public <T> T find(Class<T> entityClass, Object primaryKey);
```

캐시가 있기 때문에 조회를 하게 된다면 캐시를 먼저 뒤지고, 그 다음 데이터베이스에서 조회를 한다.

![KakaoTalk_Photo_2024-03-20-22-55-17 002jpeg](https://github.com/nashs789/Book-Study/assets/59809278/16961824-02db-45f2-a46f-93cc28631c53)

1차 캐시에 없다면 엔티티 매니저는 데이터베이스를 조회해서 엔티티를 생성하고, 1차 캐시에 저장한 후 영속 상태인 엔티티를 반환한다.

![KakaoTalk_Photo_2024-03-20-22-55-17 003jpeg](https://github.com/nashs789/Book-Study/assets/59809278/7400cf9a-eaff-4e4c-8cd8-9e7a82b6d510)

또한 key, value 형식으코 캐시에 매핑되어 있기 때문에 같은 식별자를 갖는 엔티티 인스턴스 동일성(==) 비교를 해도 참(true) 결과를 갖는다.

※ JPA는 'REPEATABLE READ' 격리 수준을 어플리케이션 레벨에서 제공한다.

### ⚙︎ <b>엔티티 등록</b>
엔티티 매니저는 트랜잭션 커밋을 실행하기전 까지는 데이터베이스에 엔티티를 저장하지 않는다.

```java
EntityTransaction transaction = em.getTransaction();

transaction.begin();   // 트랜잭션 시작
em.persist(엔티티명);    // DB에 저장하지 않음
transactioon.commit(); // DB에 저장
```

내부의 쿼리 저장소에 쿼리를 모았다가 커밋되는 시점에 데이터베이스로 보내고 이를 '<b>쓰기 지연(Transactional write-behind)</b>' 라고 한다.

![KakaoTalk_Photo_2024-03-20-22-55-17 004jpeg](https://github.com/nashs789/Book-Study/assets/59809278/d7f763d8-860d-4464-a7a6-b1012bddacf8)

커밋을 하지 않으면 영속성 컨텍스트 내부의 저장소에 모아둔다.

쓰기 지연이 가능한 이유는 뭘까?

```java
transaction.begin();

em.persist(엔티티명A);
em.persist(엔티티명B);
em.persist(엔티티명C);

transactioon.commit(); 
```

persist가 실행될 때 마다 데이터베이스에 저장한다고 가정하면 A, B가 저장에 성공했더라도 C가 저장에 실패하면 롤백이 일어난다.  
그럼 JPA와 같이 모아서 실행한다면 결과가 다를까?   
👉 아니다 결과는 똑같다. 매번 데이터베이스에 붙는 비용을 생각하면 쓰기 지연이 성능 항샹에 더 이점을 보인다.

### ⚙︎ <b>엔티티 수정</b>
SQL을 사용해서 개발을 한다고 하면 수정이 필요한 경우 어떨까?

```SQL
UPDATE MEMBER
   SET AGE = ?
 WHERE ID = ?
```

추가 사항이 생겨서 등급도 같이 변한다면?

```SQL
UPDATE MEMBER
   SET AGE = ?
     , GRADE = ?
 WHERE ID = ?
```

추가 사항이 생겨서 이름도 같이 변한다면?

```SQL
UPDATE MEMBER
   SET AGE = ?
     , GRADE = ?
     , NAME = ?
 WHERE ID = ?
```

추가 사항이 생겨서 MBTI도 변하면서 성별 조건이 추가된다면?

```SQL
UPDATE MEMBER
   SET AGE = ?
     , GRADE = ?
     , NAME = ?
     , MBTI = ?
 WHERE ID = ?
   AND SEX = ?
```

과연 SQL만 변경하면 모든게 해결될까? 정답은 아니다.  
해당 SQL을 사용하는 비지니스 로직이 담긴 코드의 변경도 필요하며 해당 컬럼을 속성으로 같는 클래스의 변경도 동반된다.  
비지니스 로직을 확인하기 위해서 SQL 파일을 열어서 SQL을 계속해서 확인해야 하는 매우 의존적인 상황이 발생하며, 이는 계층적인 분리가 전혀 아니다.

### ⚙︎ <b>변경 감지</b>
```java
// Member 라는 엔티티가 있다는 가정
Member member = em.find(Member.class, "MemberA");

member.setName("Lee In Bok");
member.setBirth("1995-12-14");
```

update 같은 메소드가 아닌 단순히 엔티티 수정만드오 데이터 베이스에 반영이된다.  

어떻게 이게 가능한 걸가?  
👉 변경 감지(Dirty Checking)을 통해서 이루어진다.

![KakaoTalk_Photo_2024-03-20-22-55-17 005jpeg](https://github.com/nashs789/Book-Study/assets/59809278/4da8369d-ca57-49d7-aa0f-7bf1cdecb77c)

영속성 컨텍스트에 보관시 최초 상태를 복사해서 저장해두는데 이것을 스냅샷(Snapshot) 이라고 한다.  
플러시 하는 순간 엔티티를 스냅샷과 비교해서 변경된 엔티티를 수정(update) 반영한다.

영속 상태인 엔티티만 관리하기 때문에 비영속이나 준영속 상태의 엔티티는 변경해도 데이터베이스에 반영되지 않는다.

※ 수정할 때 update 쿼리는 수정된 컬럼만 반영하는게 아닌 모든 컬럼을 수정한다.  
👉 단점: 실제로는 수정되지 않은 데이터도 데이터베이스까지 전송하고 update 되어야 하기 때문에 전송량이 증가한다.  
👉 장점: 
  - 수정 쿼리는 항상 같기 때문에(전체 수정) 어플리케이션 로딩시 미리 생성해서 사용할 수 있다.
  - 데이터베이스가 동일한 쿼리를 받으면 이전에 한 번 파싱된 쿼리를 사용한다.

단점에서 보았듯이 너무 많은 컬럼을 갖는 엔티티의 경우 부담이 될 수 있기 때문에 하이버네이트에서 제공하는 확장 기능인 동적 update SQL 을 생성하는 전략을 사용하도록 한다.

```java
// 동적 update SQL 생성
@org.hibernate.annotation.DynamicUpdate

// null 이 아닌 필드만 insert
@DynamicInsert
```

### ⚙︎ <b>변경 삭제</b>
삭제도 다른 동작과 같이 SQL을 저장했다가 플러시 호출시 한 번에 데이터 베이스에 전달된다.  

※ 삭제시 영속성 컨텍스트의 대상이 아니니 다시 사용하는 재호출 상황이 생기지 않도록 한다.(자연스럽게 GC의 대상이 되도록)

****

## 📌 <b>플러시</b>
영속성 컨텍스트의 변경 내용을 데이터베이스에 반영한다.

1. 영속성 컨텍스트의 엔티티들과 스냅샷을 비교해서 수정된 엔티티를 찾는다.
2. 해당하는 엔티티에 대한 쿼리를 만들어서 SQL 저장소에 등록한다.
3. 쓰기 지연 SQL 저장소의 쿼리들을 데이터베이스에 전송한다.

영속성 컨텍스트를 플러시 하는 방법에는 3가지가 있다.

1. 직접 호출

엔티티 매니저의 flush() 메소드를 직접 호출해서 영속성 컨텍스트를 플러시한다.

```java
em.flush()
```
   
2. 트랜잭션 커밋 시 플러시 자동 호출

트랜잭션이 커밋되면서 JPA 가 자동적으로 호출되어 데이터베이스에 반영된다.


3. JPQL 쿼리 실행 시 플러시 자동 호출

JPQL이나 Criteria 같은 객체지향 쿼리를 호출할 때도 플러시가 자동 실행된다.
👉 JPA 랑 같이 사용할 때 영속 상태로 만들어놓은 엔티티가 아직 반영되지 않은 데이터베이스를 JPQL이 접근할 수 있기 때문

```java
em.persist(MemberA);
em.persist(MemberB);
em.persist(MemberC);

query = em.createQuery("select m from Member m", Member.class);
List<Member> members = query.getResultList();
```

만약 플러시를 해주지 않는다면, 위에서 영속화 해놓은 엔티티들이 반영되지 않아서 JPQL의 결과도 없었을 것이다.

### ⚙︎ <b>플러시 모드 옵션</b>

```java
javax.persistence.FlushModeType
```

기본 옵션은 AUTO로 동작한다.

- FlushModeType.AUTO: 커밋이나 쿼리를 실행시
- FlushModeType.COMMIT: 커밋할 때만

****

## 📌 <b>준영속</b>
영속성 컨텍스트가 관리하지 않아서 영속성 컨텍스트가 제공하는 기능을 사용할 수 없는 상태를 말한다.

- detach(entity): 특정 엔티티만 준영속 상태로 전환
- clear(): 영속성 컨텍스트를 완전히 초기화
- close(): 영속성 컨텍스트를 종료

### ⚙︎ <b>엔티티를 준영속 상태로 전환:detach()</b>

```java
public void detach(Object entity);
```

호출하게 된다면 영속성 컨텍스트 및 쓰기 지연 SQL 저장소에서 모든 정보가 제거된다.

### ⚙︎ <b>영속성 컨텍스트 초기화: clear()</b>
영속성 컨텍스트내를 초기화 해서 영속성 컨텍스트의 모든 엔티티를 준영속 상태로 만든다.

※ 당연히 초기화 이 후에는 변경을해도 감지가 안되기 때문에 데이터베이스 반영은 없다.

### ⚙︎ <b>영속성 컨텍스트 종료: close()</b>
초기화와 미찬가지로 영속성 컨텍스트가 관리하는 엔티티들이 준영속 상태로 변경된다.

### ⚙︎ <b>준영속 상태의 특징</b>
- 비영속 상태에 가깝다.
  - 영속성 컨텍스트의 기능을 사용하지 못하니 1차 캐시, 변경 감지, 쓰기 지연, 지연 로딩 전부 불가능하다.
- 식별자 값을 가지고 있다.
  - 준영속 상태라는건 한 번 영속된 상태였기 때문에 반드시 식별자 값을 가지고 있다.
- 지연 로딩을 할 수 없다.
  - 실제 객체를 대신하는 '프록시' 객체를 두고, 객체 실사용시 데이터를 불러오는 방법이지만 영속성 컨텍스트가 관리하지 않기 때문에 불가능하다.
 
### ⚙︎ <b>병합: merge()</b>
준영속 상태에서 다시 영속 상태로 변경하는 메소드이다.

```java
public <T> T merge(T entity);
```

병합 시 1차 캐시에 없다면 데이터베이스를 조회하고, 데이터베이스에도 없다면 새로운 엔티티를 생성해서 병합한다.  
병합은 준영속, 비영속을 신경쓰지 않고 save or update 를 수행한다.

****
