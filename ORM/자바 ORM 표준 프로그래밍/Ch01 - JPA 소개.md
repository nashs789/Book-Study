# **Chapter01 - JPA 소개**

# **[ 📋 목차 ]**
- SQL 을 직접 다룰 때 발생하는 문제점
- 패러다임의 불일치
- JPA 란 무엇인가?
- 정리

****

# **[ 🗂️ 정리 ]**
관계형 데이터베이스 RDB(Relational Database)는 대중적이고 신뢰할 수 있는 데이터 저장소로 자바 어플리케이션은 
RDB 를 자주 사용하고, Java 에서 RDB 를 사용하기 위해서 JDBC(Java Database Connectivity) API 를 사용해서 SQL 을 전송해 DB 를 조작한다.

### 📌 SQL 을 직접 다룰 때 발생하는 문제점
1. 객체를 조회할 select SQL 작성
2. JDBC API 로 작성한 SQL 실행
3. 조회 결과를 받아서 객체로 매핑

위와 같이 단순 조회를 하는 코드를 작성한 후 등록하는 코드도 작성한다면?

1. 삽입할 insert SQL 작성
2. 객체에서 데이터를 꺼내서 SQL 에 전달
3. JDBC API 로 작성한 SQL 실행

조회와 삽입이 다른 기능이지만 비슷한 부분이 많다.
  
그 보다 더 큰 문제는 객체를 직접 저장할 수 없기 때문에 객체 구조와는 전혀 다른 데이터 중심의 구조를 갖는다.  
개발자가 어플리케이션과 데이터베이스 중간에서 변환 작업을 해주는 것이다.  
그렇기 때문에 개발자는 CRUD 를 위해서 많은 시간을 SQL 과 JDBC API 코드 작성에 써야한다.

> 나는 myBatis 사용해서 JDBC 코드까지 작성하지는 않았지만... 그래도 작성해야하는 쿼리가 있으니까

#### ⚙︎ 반복, 반복 그리고 반복
데이터 접근 계층(DAO) 을 개발하는건 무수한 반복의 연속이다.  
  
반복만 있다면 괜찮을지 모르겠지만 다른 문제도 있다.
기존에 작성해둔 SQL 을 뒤로하고 새로운 컬럼이 추가되어서 추가해달라고 한다면?

1. 객체에 새로운 '필드' 추가
2. SQL 에 객체로부터 파라미터 전달
3. SQL 변경

전체적은 코드 변경이 이루어진다.

#### ⚙ SQL 에 의존적인 개발
테이블에 새로운 컬럼이 추가 된서 단순히 쿼리만 수정 한다면 어떻게 될까?  
모든 CRUD 쿼리를 수정해야 하고, 뿐만 아니라 서버의 비지니스 로직도 병행해서 수정해야 한다. (Select, Insert, Delete)  

그렇다면 객체 안에서 다른 객체를 관리 한다면 어떨까? ('회원' 이 어느 '팀' 에 속하는지)  
기존 조회 쿼리로는 또 조회가 안되는 문제가 발생할 것이다.  
문제를 해결하기 위해서 join 을 이용한 조회 쿼리를 새로 만들어서 사용해야 한다.  

이런 상황은 매번 DAO 파일을 확인해서 SQL 을 확인해야 하게 만들고, 데이터 접근 계층과 물리적으로는 계층적으로 분리가 되어 있음에도
불구하고, 논리적으로는 아주 의존적은 관계를 맺는다.
  
정리 하자면
- 진정한 계층 분할이 아니다.
- 엔티티를 신뢰할 수 없다.
- SQL 에 의존적인 개발이 지속된다.

#### ⚙ JPA 와 문제 해결
JPA 는 개발자가 직접 SQL 을 작성 하는게 아니라 JPA 가 적절한 쿼리를 생성해 데이터베이스에 질의한다.
  
단지 메소드 하나의 호출로 조회(select - find()) 를 할 수 있고, 객체의 데이터를 수정함으로 데이터를 변경(update) 할 수 있다.

****

### 📌 패러다임의 불일치
- 관계형 데이터베이스: 데이터 중심 구조
- 객체지향: 

어플리케이션은 객체지향 언어인 자바로 개발하고, 데이터는 관계형 데이터베이스에 저장해야 하니 패러다임의 불일치 문제가 생겨서 개발자가 중간애서
시간을 소모하며 해결하는 상황이 생긴 것이다.


#### ⚙ 상속
테이블은 상속이라는 개념이 없다.  
Super type 과 Sub type 으로 나뉠 수 있지만

그림[1.3] 41

하지만 이 상황에서 두 개의 insert 쿼리를 작성해야 데이터를 저장할 수 있으며, 조회할 때는 조인을 이용해서 조회해야 한다.

```
// 만약에 자바로 코드를 해결 했다면
list.add(album);
list.add(movie);

Album album = list.get(albumId);
```

단순하게 해결이 되었을 것이다. (그저 넣고, 꺼내서 사용하면 된다.)  
JPA 는 단순히 객체만 저장하면서도 이 문제를 해결해준다.

#### ⚙ 연관관계
- 객체: 다른 객체를 참조해서 연관관계를 맺고 데이터를 조회한다.
- 테이블: 외래 키를 두어 다른 테이블과 연관관계를 맺고 조인을 이용해 연관된 데이터를 조회한다.

그림[1.4] 44

패러다임이 다르기 때문에 발생하는 비용을 중간에서 개발자가 처리한다.

- 테이블에 맞춤: 객체가 다른 객체를 참조하지 않고 있어 조인 쿼리를 사용하는 데이터베이스는 편할지 몰라도 객체 입장에선 관계된 객체 조회가 불가능하다.
- 객체에 맞춤: 연관된 객체를 참조하고 있어서 어플리케이션 레벨에서는 편할 수 있지만 조회하고 저장하는데 여러번 거쳐야하는 불편함이 있다.

'JPA' 는 객체가 참조하고 있는 객체에 값을 저장하고, 변경해도 데이터베이스에 알맞는 DML 을 전달한다.

#### ⚙ 객체 그래프 탐색

그림[1.5] 48

객체 그래프만 보면 시작점에서 모든 객체를 탐색할 수 있어 보이지만 실제로는 작성된 SQL 에 따라서 조회할 수 있는 객체의 범위가 정해진다.

```sql
select *
  from member m 
  left outer join team t
    on m.team_id = t.team_id
```

이런 SQL 이 작성되어 있다면 실제로 조회할 수 있는 데이터는 Member, Team 두개의 클래스 객체 뿐이다.  
이 내용 또한 SQL 에 의존적이고, 그렇다고 어플리케이션 메모리에 그래프에 해당하는 모든 데이터를 조회해서 올려 둘수도 없는 노릇이다.
  
'JPA' 가 객체 그래프를 이런 이런 문제 없이 탐색할 수 있도록 도움을 준다.  
먼저 객체가 사용되는 시점에 SQL 이 실행되어 메모리에 전부 올려둘 필요 없게되고, 이를 <b>지연로딩</b>이라 부른다.

****

### 📌 JPA 란 무엇인가?
JPA(Java Persistence API) 란 자바 진영의 ORM 기술 표준이다.  
어플리케이션과 JDBC 사이에서 동작한다.
  
ORM(Object-Relational Mapping) 은 객체와 RDB 를 매핑 한다는 뜻이다.  
앞에서 봤듯이 패러다임의 불일치를 해결하기 위해서 객체와 테이블을 매핑해서 사용한다.

#### ⚙ JPA 소개
하이브네이트를 기반으로 새로운 자바 ORM 기술 표준이 만들어진게 JPA 다.

그림[1.9] 56

JPA 는 자바 ORM 기술에 대한 API 표준 명세다.  
JPA 를 사용하려면 JPA 를 구현한 ORM 프레임워크를 선택해야 한다. (대중적으로 Hibernate)

#### ⚙ 왜 JPA 를 사용해야 하는가?
- 생산성: 당연하게도 단순 반복 작업인 SQL 작성을 하지 않아도 된다. (복잡한 SQL 이 아니라)
- 유지보수: 데이터 중심 설계의 경우 SQL 에 의존적이기 때문에 변경이 있는 경우 연쇄적으로 많은 수정사항이 일어났지만 이제는 JPA
    가 대신해서 문제를 처리해준다.
    
    때문에 패러다임 불일치를 해결해 객체지향 언어가 가진 장점을 살려 유지보수하기 좋은 도메인 모델을 설계 가능하다.
- 패러다임 불일치
- 성능: 같은 작업을 할 때는 메모리에 저장된 데이터를 사용하여 성능적인 측면이 고려 되었다.
- 데이터 접근 추상화와 벤더 독립성: 선택한 데이터베이스에 따라서 기술이 종속되어서 다른 데이터베이스 채택이 힘들었지만 JPA 는 어플리케이션과
    데이터베이스 사이에서 추상화된 계층을 제공해 데이터베이스에 종속되지 않도록 한다.